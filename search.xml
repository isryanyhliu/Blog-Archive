<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/Blog00.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>
<center>This post is created for test

<p>=_=</p>
<br>

<p>But, thanks for reading</p>
<p>Wish u a nice day</p>
</center>]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>与桂林某电子科技大学的校园网的防火墙斗智斗勇</title>
    <url>/Blog01.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>



<p>注：<br><br><em>请遵守中国大陆法律规定！</em><br><em>本文所记录的技术与过程仅为技术交流！切勿将其运用在其它地方！</em><br><em>若读者模仿并将其移用至别处，与本文作者无关！</em><br><em>感谢您的阅读和理解！</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近一直在玩一款名为部落冲突的手游，玩过的同学都知道，这个游戏到了中后期全靠肝。而作为一名优秀（懒得动手刷资源）的程序员，面对这种需要进行反复无意义的劳动时，就要有符合程序员核心价值观的意识——能用脚（本）解决的事情，就绝不动手！本来电脑开模拟器用脚本刷的开开心心，但是我最近由于某些个人原因，在一个月黑风高的夜晚，把电脑搬回了学校实验室。然后发现，游戏打开后就黑屏（进不去游戏）。<br><br><br><br>so——问题出现了，我们就要解决它！</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>首先要分析一下问题。<br></p>
<p>部落冲突打不开了，可能的原因有好几种：<br></p>
<p><strong>1.服务器坏了？</strong><br>没有。手机依然可以登陆；</p>
<p><strong>2.客户端坏了？</strong><br>没有。各个商店里的各个版本我都尝试过，不太可能出现这种事故<br><em>（当你觉得全世界有问题的时候，不妨先想想是不是自己的问题）</em></p>
<p>那么除却以上两点，出问题的可能就是网络了。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>打开模拟器的浏览器，发现一切正常。各种app也都可以使用，貌似只有部落冲突不能用。<br>到这里其实大家都应该有所感觉——会不会是这个游戏被屏蔽了呢？<br>验证的方法也很简单，如果学校要屏蔽游戏的话，那么首当其冲的肯定是</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src=".//Blog01/blog01_Gfat.png" alt><br><em>G胖：天天搞优惠亏钱就算了，到头来还要被屏蔽</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>果然<br><img src=".//Blog01/blog01_Steam.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>那么问题的所在就一目了然了——是学校的防火墙从中作梗！<br><img src=".//Blog01/blog01_Traitor.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>从原理上来说，我只要穿透这个防火墙就可以了<br>大家都听说过翻墙，只不过我现在要翻的是SchoolFireWall</p>
<p>既然要翻墙，那么首先需要搭一个代理服务器（俗称梯子）<br>我想了一圈，宿舍那边入户的网线没有屏蔽掉Steam，而且如果可以用的话，时延比起来外网的vps要小很多。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>于是我找到我宿舍的同学，让他帮我搭一个Linux虚拟机。<br>那么整体的网络架构应该是如下图所示的<br><img src=".//Blog01/blog01_Net.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>同学用的虚拟机是Windows10的子系统Ubuntu（Win10应用商店里的那个）<br>我查了一下，这个虚拟机和真机共享IP，即vmware的默认网卡模式（下图）<br><img src=".//Blog01/blog01_VMware.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>同学在虚拟机中部署好ssh并启动，把虚拟机用户帐密发给我，我在实验室进行连接并控制<br>这里为了避免与QQ抢端口，建议将其端口号改为23<br>那么网络架构图中右下角部分就算是打通了。</p>
<p>与此同时，我让同学使用windows cmd中的<strong>tracert ip</strong>命令，查询到了宿舍路由器的ip<br>（该命令可以跟踪数据包所经过的网关的ip）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>在下图这个例子中，<strong>第二个跃点为外网分配给路由器的ip</strong><br><img src=".//Blog01/blog01_TraceIP.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>我在实验室ping了一下第二个跃点（宿舍路由器）的ip，可以ping通<br>那么接下来只需要解决从路由器到同学的pc这一段即可</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>登陆路由器管理界面，找到高级设置中的DMZ功能（IP映射）<br>这个功能可以理解为将该路由器内网中的某一设备的ip映射到自己身上<br>也就是外网数据包发送到路由器的IP时，路由器会自动转发其到内网某一指定设备<br><img src=".//Blog01/blog01_MIwifi.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>最后，测试可以从实验室ssh连接到寝室的代理服务器。<br>当然，这个只是测试，总不能一直让同学开着虚拟机给我当代理服务器。<br>日后只需要用手里现成的树莓派3B就可以了。</p>
<p>代理服务器的问题已经解决了，我在电脑上信心满满的打开ShadowSocks客户端<br>连上代理服务器，切换为全局模式，双击steam图标，经过紧张的等待后</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src=".//Blog01/blog01_bqb.png" alt></p>
<p>还是上不去steam</p>
<p>很正常，生活嘛，总是起起落落落落落落落落落。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>经过我冷静的分析（划掉），以及google公司的鼎力相助<br></p>
<p>原来ShadowSocks客户端的全局模式并不是类似于VPN那种，可以代理本地的所有流量。<br>ShadowSocks的全局代理只是sock5代理，即只有http和socks数据会走代理</p>
<p>游戏有很多是udp，而大部分http都是用的tcp，所以我猜测steam和部落冲突的流量并没有走代理</p>
<p>解决方法是使用一个由<a href="https://www.zhihu.com/people/tao-neng-yi" target="_blank" rel="noopener">@AHaLa</a> 这位大佬提供的工具—— <a href="https://baike.baidu.com/item/proxifier/10859305" target="_blank" rel="noopener">proxifier_百度百科</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>通过网上的教程，使用ShadowSocks和proxifier将本机网络指定走代理（vpn）化之后<br>我兴奋的搓起了手，那感觉就像是革命胜利的前夕，不会再有压迫了！</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>但是，革命这种事情，总是一波三折<br></p>
<p>学校的防火墙除了防火墙最基本的IP封锁之外，还有另一个功能——DNS污染<br>在我尝试了指定DNS服务器以及修改hosts的方法发现二者均行不通</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>不过还好，proxifier提供了远程DNS解析<br><img src=".//Blog01/blog01_proxifierDNS.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>在看了几篇缺斤少两的博客之后，找到了一篇正确的<a href="https://lollogit.gitbooks.io/help/ssdian_nao_xi_tong_quan_ju_dai_li_jiao_cheng/shi_yong_proxifier_ba_ss_zhuan_wei_quan_ju_jia_su_.html" target="_blank" rel="noopener">proxifier和ShadowSocks将本地网络vpn化</a>教程（除了开启远程解析，还要把小飞机代理的的端口填入直连名单）最终，我成功的连上了steam网络！</p>
<p>看吧，只要思想不滑坡，方法总比困难多（wdnmd劳资csgo新买的皮肤还没好好看几眼）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>其实过程到这里就差不多结束了，但是吧~~</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><p>我来到实验室之后，发现昨天成功启动了脚本的部落冲突居然没有正常运行。仔细一看发现，我的电脑没网络了。一拍脑袋想到，学校的上网是要登陆的，每天晚上会把在线的强制下线。所以，要让它自动上线才可以</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>我google了一下相关的资料，在看过好多大神的思路之后，下载了一个名为<strong>Fiddler</strong>的抓包软件。Wireshark之前上计网的实验课倒是用过，但是比较复杂，杀鸡何用宰牛刀（其实是我忘了怎么用）<br><img src=".//Blog01/blog01_Fidder.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>通过抓取数据包，我发现学校的登陆系统是通过GET方式直接发送数据包，这就大大降低了难度，因为Get方式发送的话，用户名和密码是明文写在url里的。我发现登陆过程中一共产生了3个数据包，而第三个数据包就是名为login的登录信息，把它的url复制，存到txt里<br><img src=".//Blog01/blog01_TXT.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>只要把图中的DDDDD和upass换成自己的学号和密码就可以了，于是我手动注销，然后用浏览器直接访问改好的url。果然，并不需要经过登陆页面，直接就登陆成功了。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>那么接下来要做的，就是编写一个程序，实现这个功能。<br></p>
<p>大概的思路是，一直ping 8.8.8.8，如果可以ping通，则可以访问；如果不能ping通，则代表账户已被下线，需要访问指定的url。这里我使用python来实现。最后，再加上死循环让程序一直检测就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(os.system(<span class="string">'ping -c 8.8.8.8'</span>) == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Connect SUCCESS'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Connect FALSE'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        s = urllib2.urlopen(<span class="string">'此处为txt中修改好的URL'</span>)</span><br><span class="line">    <span class="keyword">except</span> urllib2.HTTPError, e:</span><br><span class="line">        <span class="keyword">print</span> e.code</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        ping()</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">do()</span><br></pre></td></tr></table></figure>


<p>本地测试之后发现一切正常，我便把它丢到树莓派上运行了，这样就可以保证我路由器下的所有子设备都可以保持7*24在线。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>大概就是这样了，第二天就可以看到全部刷满的资源（斜眼笑）。其实我本来想用树莓派直接搭全局代理，但是现在的资料貌似有点过时，树莓派的openwrt一直不出，lede的ss框架也不太好用，部署的证书都是过期的，pc基本没法用。如果走过路过的看官有相关资料的，还望指点迷津~</p>
<p>感谢阅读，以上</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>python</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>变量名是否占用内存</title>
    <url>/Blog03.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p><strong>想看结论的直接拖到最后</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>变量名究竟是否占用内存呢？</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>今天在网上看见这么一张图，里边有这么一句话不是很理解<br><img src=".//Blog03/blog03.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>为什么这样会浪费内存空间呢，我花了三个小时在网上查了些资料，整理了一下，具体如下：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>变量名编译后，变成一个内存地址</p>
<p>这个内存地址一般是直接存在于<font color="#00AB6F"><strong>代码段</strong></font>中</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>那么什么是<font color="#00AB6F"><strong>代码段</strong></font>呢？</p>
<p>一般把程序所占的主存空间分为（从低到高）：<br></p>
<p>1.<font color="#00AB6F"><strong>代码段</strong></font><br><br>2.数据段<br></p>
<p>3.栈<br><br>4.堆<br></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>其中，<font color="#00AB6F"><strong>代码段</strong></font>和数据段 是 <font color="#FF4900"><strong>编译期间</strong></font>就确定的</p>
<p>所以在整个程序编译期间，都占用内存空间</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>程序又分为<font color="#FF4900"><strong>编译期间</strong></font>和运行期间</p>
<p>变量名是在<font color="#FF4900"><strong>编译期间</strong></font>占用内存（所以那张截图里没说错）<br><br>而大多情况下，我们讨论的是运行期间</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>结论：</p>
<p>变量名 在  运行期间  是    不占内存的<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在  编译期间  是        占内存的</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>相关资料：<br><br><a href="http://blog.csdn.net/qianqin_2014/article/details/51114105" target="_blank" rel="noopener">http://blog.csdn.net/qianqin_2014/article/details/51114105</a><br><br><a href="http://bbs.csdn.net/topics/70123909" target="_blank" rel="noopener">http://bbs.csdn.net/topics/70123909</a></p>
]]></content>
      <tags>
        <tag>编译原理</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>通过邻接表实现广度优先搜索（迷宫问题）</title>
    <url>/Blog04.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p><strong>“Talk is cheap. Show me the code.”  — Linus Torvalds</strong><br></p>
<p>直接上代码，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment">            问题：迷宫问题 </span></span><br><span class="line"><span class="comment">            算法：广度优先搜索 </span></span><br><span class="line"><span class="comment">         数据结构：邻接表 </span></span><br><span class="line"><span class="comment">***************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R 7 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Branch</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> row;</span><br><span class="line">	<span class="keyword">int</span> column;</span><br><span class="line"></span><br><span class="line">	_Branch * nextBranch;</span><br><span class="line">&#125;</span><br><span class="line">* Branch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Root</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> row;</span><br><span class="line">	<span class="keyword">int</span> column;</span><br><span class="line"></span><br><span class="line">	_Root * nextRoot;</span><br><span class="line">	_Branch * nextBranch;</span><br><span class="line">&#125;</span><br><span class="line">* Root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////全局变量 </span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[R][R];<span class="comment">//迷宫 </span></span><br><span class="line">Root treeRoot;<span class="comment">//树根 </span></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">1</span>;<span class="comment">//第几层 </span></span><br><span class="line"><span class="comment">/////////////////////// </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n---------------------------------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; R; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\t□"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\t%d"</span>, <span class="built_in">map</span>[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Branch <span class="title">findBranch</span><span class="params">(Root tempRoot, <span class="keyword">int</span> templevel)</span><span class="comment">//寻路 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Branch tempBranch = (struct _Branch *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct _Branch));	</span><br><span class="line">	<span class="keyword">int</span> tempRow = tempRoot -&gt; row;</span><br><span class="line">	<span class="keyword">int</span> tempColumn = tempRoot -&gt; column;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//up</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>[tempRow - <span class="number">1</span>][tempColumn] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tempBranch -&gt; row = tempRow - <span class="number">1</span>;</span><br><span class="line">		tempBranch -&gt; column = tempColumn;</span><br><span class="line">		<span class="built_in">map</span>[tempRow - <span class="number">1</span>][tempColumn] = templevel + <span class="number">1</span>;<span class="comment">//等于当前的层数加一 </span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> tempBranch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[tempRow - <span class="number">1</span>][tempColumn] == <span class="number">9</span>)<span class="comment">//出口是9 </span></span><br><span class="line">	&#123;</span><br><span class="line">		level = <span class="number">0</span>;<span class="comment">//找到了出口，把当前层数变成0，并返回NULL </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//right</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>[tempRow][tempColumn + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tempBranch -&gt; row = tempRow;</span><br><span class="line">		tempBranch -&gt; column = tempColumn + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">map</span>[tempRow][tempColumn + <span class="number">1</span>] = templevel + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> tempBranch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[tempRow][tempColumn + <span class="number">1</span>] == <span class="number">9</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		level = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//down</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>[tempRow + <span class="number">1</span>][tempColumn] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tempBranch -&gt; row = tempRow + <span class="number">1</span>;</span><br><span class="line">		tempBranch -&gt; column = tempColumn;</span><br><span class="line">		<span class="built_in">map</span>[tempRow + <span class="number">1</span>][tempColumn] = templevel + <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> tempBranch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[tempRow + <span class="number">1</span>][tempColumn] == <span class="number">9</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		level = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//left</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>[tempRow][tempColumn - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tempBranch -&gt; row = tempRow;</span><br><span class="line">		tempBranch -&gt; column = tempColumn - <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">map</span>[tempRow][tempColumn - <span class="number">1</span>] = templevel + <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> tempBranch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[tempRow][tempColumn - <span class="number">1</span>] == <span class="number">9</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		level = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addRoot</span><span class="params">(Branch tempBranch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Root tempRoot = (struct _Root *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(struct _Root));</span><br><span class="line">	Root tempBranchRoot = (struct _Root *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(struct _Root));</span><br><span class="line">	<span class="comment">//初始化 </span></span><br><span class="line">	&#123; </span><br><span class="line">		tempBranchRoot -&gt; row = tempBranch -&gt; row;</span><br><span class="line">		tempBranchRoot -&gt; column = tempBranch -&gt; column;</span><br><span class="line">		tempBranchRoot -&gt; nextBranch = <span class="literal">NULL</span>;</span><br><span class="line">		tempBranchRoot -&gt; nextRoot = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	tempRoot = treeRoot;</span><br><span class="line">	<span class="keyword">while</span> (tempRoot -&gt; nextRoot != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tempRoot = tempRoot -&gt; nextRoot;</span><br><span class="line">	&#125;</span><br><span class="line">	tempRoot -&gt; nextRoot = tempBranchRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createRoot</span><span class="params">(Root tempRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Branch tempBranch = (struct _Branch *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct _Branch));</span><br><span class="line">	tempBranch = tempRoot -&gt; nextBranch;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tempBranch != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		addRoot(tempBranch);<span class="comment">//把当前branch变成root </span></span><br><span class="line">		tempBranch = tempBranch -&gt; nextBranch;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Root tempRoot = (struct _Root *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(struct _Root));</span><br><span class="line">	Branch tempBranch = (struct _Branch *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct _Branch));</span><br><span class="line">	Branch lastBranch = (struct _Branch *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct _Branch));</span><br><span class="line">	</span><br><span class="line">	tempRoot = treeRoot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (level != <span class="number">0</span>)<span class="comment">//标识符，如果为0就代表找到了出口 </span></span><br><span class="line">	&#123;</span><br><span class="line">		tempBranch = findBranch(tempRoot, <span class="built_in">map</span>[tempRoot -&gt; row][tempRoot -&gt; column]);</span><br><span class="line">		<span class="comment">//为当前root建立branch </span></span><br><span class="line">		<span class="keyword">while</span> (tempBranch != <span class="literal">NULL</span>)<span class="comment">//如果还有branch </span></span><br><span class="line">		&#123;</span><br><span class="line">			tempBranch -&gt; nextBranch = <span class="literal">NULL</span>;</span><br><span class="line">			tempRoot -&gt; nextBranch = tempBranch;</span><br><span class="line">			lastBranch = tempBranch;</span><br><span class="line"></span><br><span class="line">			tempBranch = findBranch(tempRoot, <span class="built_in">map</span>[tempRoot -&gt; row][tempRoot -&gt; column]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (tempBranch != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				lastBranch -&gt; nextBranch = tempBranch;</span><br><span class="line">				lastBranch = tempBranch;</span><br><span class="line">				tempBranch = findBranch(tempRoot, <span class="built_in">map</span>[tempRoot -&gt; row][tempRoot -&gt; column]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		createRoot(tempRoot);<span class="comment">//把当前root的branch创建成root，放在表尾 </span></span><br><span class="line">		tempRoot = tempRoot -&gt; nextRoot;<span class="comment">//接着寻找下一个root </span></span><br><span class="line"></span><br><span class="line">		printMap();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">5</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">1</span>] =  <span class="number">1</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">2</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">3</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">4</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">5</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">3</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">3</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">4</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">1</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">2</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">3</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">4</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">5</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">5</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">2</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">3</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">5</span>] =  <span class="number">9</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">6</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">2</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">3</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">4</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">5</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">6</span>] = <span class="number">-1</span>; </span><br><span class="line">	printMap();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化根 </span></span><br><span class="line">	&#123;</span><br><span class="line">		treeRoot = (struct _Root *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(struct _Root));</span><br><span class="line">		treeRoot -&gt; nextRoot = <span class="literal">NULL</span>;</span><br><span class="line">		treeRoot -&gt; row = <span class="number">1</span>;</span><br><span class="line">		treeRoot -&gt; column = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	createTree();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>迷宫问题</tag>
        <tag>广度优先</tag>
        <tag>邻接表</tag>
        <tag>C语言</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建基于Hexo的网站遇到的一些坑（2020.04）</title>
    <url>/Blog05.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p><em>非教程，仅用于记录自己搭建该网站遇到的一些问题和经验，以供大家参考，如有帮助不胜荣幸</em><br><em>本网站搭建于2020年4月份，Hexo版本号为 hexo-cli: 3.1.0; NexT主题版本为 5.1.4;</em><br><em>本文所记录的问题也是基于这个时间段、这个版本。不具有普遍适用性</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<font size="6">
<center>可以通过左侧导航栏，更方便的进行阅读</center>
</font>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="项目配置文件-amp-主题配置文件"><a href="#项目配置文件-amp-主题配置文件" class="headerlink" title="项目配置文件&amp;主题配置文件"></a>项目配置文件&amp;主题配置文件</h1><p><img src=".//Blog05/TwoConfigFiles.png" alt></p>
<p>如上图所示，整个项目里有两个配置文件( _config.yml )。它们分别位于项目根目录下、项目主题根目录下。项目根目录下的称其为项目配置文件、主题根目录下的称其为主题配置文件。在参考别人教程的时候切记不要改错了文件</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="边写博客边预览"><a href="#边写博客边预览" class="headerlink" title="边写博客边预览"></a>边写博客边预览</h1><p>我写博客使用的工具是VSCode，安装了三个插件如下：<br><img src=".//Blog05/MarkDownPlugin.png" alt></p>
<center>MarkDown All in One | Markdown Preview Github Styling | markdownlint</center>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>其中第二个插件是在VSCode里开一个侧栏，以提供MarkDown实时预览的，效果如下：<br><img src=".//Blog05/MarkDownPreview.png" alt><br>如果你仔细查看的话，可以看到，这个插件的显示效果与实际Hexo解析出的静态页面效果不一样。其中的图片与文字并未显示出换行效果，但是Hexo进行解析的时候会加上换行。Hexo有一个好处就是，可以进行实时预览，并不需要借助插件，具体的操作是: 首先<code>hexo s</code>启动本地Hexo服务，在浏览器输入<code>localhost:4000</code>打开页面。修改完当前MarkDown后，按下<code>Ctrl S</code>保存。之后在浏览器刷新当前页面即可。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="如何在电脑上进行移动端预览"><a href="#如何在电脑上进行移动端预览" class="headerlink" title="如何在电脑上进行移动端预览"></a>如何在电脑上进行移动端预览</h1><p>我使用的是基于chromium内核的Chrome和Edge这两款浏览器，对于它们而言，开启移动端预览的方法是相同的。打开浏览器，按<code>F12</code>，点击切换设备工具栏（如下图红色箭头指向）/ 也可以通过快捷键 <code>Ctrl + Shift + M</code>切换到移动端模式。通过左侧移动端预览上边的工具栏还可以自定义宽高的像素，选择预设机型，修改显示比例，修改网络环境和CPU（模拟老旧设备，弱网络环境）等选项<br><img src=".//Blog05/MobileMode.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="Hexo-常用命令的含义"><a href="#Hexo-常用命令的含义" class="headerlink" title="Hexo 常用命令的含义"></a>Hexo 常用命令的含义</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g      &#x2F;&#x2F;generate，保存后执行该命令，以重新生成文件</span><br><span class="line">hexo s      &#x2F;&#x2F;server，  启动本地服务器，进行预览</span><br><span class="line">hexo d      &#x2F;&#x2F;deploy，  部署本地项目到远程服务器</span><br><span class="line">hexo clean  &#x2F;&#x2F;清除本地静态文件（db.json，根目录public文件夹）</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="菜单显示、配置问题"><a href="#菜单显示、配置问题" class="headerlink" title="菜单显示、配置问题"></a>菜单显示、配置问题</h1><p>下图所示即为菜单部分<br><img src=".//Blog05/MenuDisplay.png" alt></p>
<p>我这个版本的NexT主题配置好了之后，默认只有Home、Category两个页面。这里有一个小坑就是<strong>配置页面时，修改的是主题配置文件</strong>，而不是项目配置文件。</p>
<p>执行命令<code>hexo new page &quot;PAGENAME&quot;</code>即可在目录<code>/source/</code>下新建一个菜单页的相关文件夹，里边便是该页的配置文件，如下图：<br><img src=".//Blog05/AboutmePage.png" alt></p>
<p>一开始我新建页面之后，点击菜单，跳转失败（找不到当前页面）。我看了一下浏览器的地址栏，发现跳转的时候URL会莫名其妙的多出来一个<code>%20%</code>，即多出来了一个空格。这其中的原因是在主题配置页面，把菜单配置中分隔符<code>||</code>左右的空格都给去掉就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 关于菜单示例配置</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F;||home</span><br><span class="line">  about: &#x2F;about&#x2F;||user</span><br><span class="line">  tags: &#x2F;tags&#x2F;||tags  </span><br><span class="line">  archives: &#x2F;archives&#x2F;||archive</span><br></pre></td></tr></table></figure>
<p>PS: 如果遇到Archives的ICON显示不出来的问题，不妨看看是不是archive多加了一个s，哈哈哈哈</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="粒子漂浮背景"><a href="#粒子漂浮背景" class="headerlink" title="粒子漂浮背景"></a>粒子漂浮背景</h1><p>效果图预览：<br><img src=".//Blog05/lizipiaofuPicture.png" alt><br>配置方法：执行该命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;canvas-nest</span><br></pre></td></tr></table></figure>

<p>然后在<strong>主题配置文件</strong>中，找到该项并如下设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure>

<p>但是如果你在移动端（真机）上预览，会发现这个背景会显得博客十分杂乱无章。这个的解决办法是要配置成<code>NexT v6.5.0</code>及其以上的版本，如果你进行了配置，可以通过以下的代码对粒子漂浮背景进行更多的设置。如果你像我这个憨憨一样用的是v5以下的版本，就只能暗自骂街了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # 是否在移动端显示</span><br><span class="line">  color: &#39;0,0,255&#39; # 动态背景中线条的 RGB 颜色</span><br><span class="line">  opacity: 0.5 # 动态背景中线条透明度</span><br><span class="line">  zIndex: -1 # 动态背景的 z-index 属性值</span><br><span class="line">  count: 99 # 动态背景中线条数量</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="如何默认展开多级标题"><a href="#如何默认展开多级标题" class="headerlink" title="如何默认展开多级标题"></a>如何默认展开多级标题</h1><p>在该路径文件下添加以下代码<br>路径： <code>/themes/next/source/css/_custom/custom.styl</code><br>代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//默认展开标题</span><br><span class="line"><span class="selector-class">.post-toc</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-child</span> &#123; </span><br><span class="line">    <span class="attribute">display</span>: block; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="侧边栏头像"><a href="#侧边栏头像" class="headerlink" title="侧边栏头像"></a>侧边栏头像</h1><p>效果图：<br><img src=".//Blog05/Avatar.png" alt><br>这个头像一定要是gif格式的，可以把png格式的图片直接修改拓展名变成gif，gif动图能否做头像我没尝试过。<br>把gif文件放在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;themes&#x2F;next&#x2F;source&#x2F;uploads&#x2F;</span><br></pre></td></tr></table></figure>
<p>目录下，然后修改<strong>主题配置文件</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">    avatar: &#x2F;uploads&#x2F;avatar.gif</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="网站运行时间统计"><a href="#网站运行时间统计" class="headerlink" title="网站运行时间统计"></a>网站运行时间统计</h1><p>效果图：<br><img src=".//Blog05/FooterRunTime.png" alt><br>在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig</span><br></pre></td></tr></table></figure>
<p>目录文件下，添加如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"timeDate"</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"times"</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">createtime</span><span class="params">()</span> </span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"04/06/2020 21:00:00"</span>);<span class="comment">//在此处修改你的建站时间，格式：月/日/年 时:分:秒</span></span></span><br><span class="line">        now.setTime(now.getTime()+250); </span><br><span class="line"><span class="javascript">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="built_in">Math</span>.floor(days); </span></span><br><span class="line"><span class="javascript">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="built_in">Math</span>.floor(hours); </span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">String</span>(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">"0"</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum); </span></span><br><span class="line"><span class="javascript">        mnum = <span class="built_in">Math</span>.floor(minutes); <span class="keyword">if</span>(<span class="built_in">String</span>(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">"0"</span> + mnum;&#125; </span></span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); </span><br><span class="line"><span class="javascript">        snum = <span class="built_in">Math</span>.round(seconds); <span class="keyword">if</span>(<span class="built_in">String</span>(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">"0"</span> + snum;&#125; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"timeDate"</span>).innerHTML = <span class="string">"我已在此等候你 "</span>+dnum+<span class="string">" 天 "</span>; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"times"</span>).innerHTML = hnum + <span class="string">" 小时 "</span> + mnum + <span class="string">" 分 "</span> + snum + <span class="string">" 秒"</span>; </span></span><br><span class="line">    &#125; </span><br><span class="line"><span class="actionscript">setInterval(<span class="string">"createtime()"</span>,<span class="number">250</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="关于版权声明、搞怪标题、站内搜索、网站访问量"><a href="#关于版权声明、搞怪标题、站内搜索、网站访问量" class="headerlink" title="关于版权声明、搞怪标题、站内搜索、网站访问量"></a>关于版权声明、搞怪标题、站内搜索、网站访问量</h1><p>请访问Yearito大神的博客<br><a href="http://yearito.cn/posts/hexo-advanced-settings.html" target="_blank" rel="noopener">Hexo搭建个人博客系列：进阶设置篇</a> </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="关于文章结束标记、看板娘、鼠标点击特效"><a href="#关于文章结束标记、看板娘、鼠标点击特效" class="headerlink" title="关于文章结束标记、看板娘、鼠标点击特效"></a>关于文章结束标记、看板娘、鼠标点击特效</h1><p>请访问Yearito大神的博客<br><a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="noopener">Hexo搭建个人博客系列：主题美化篇</a> </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>个人网站SEO及其它优化</title>
    <url>/Blog06.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>
<p>SEO，是Search Engine Optimization的缩写，中文意思是搜索引擎优化。通俗的说，就是如何让你自己的网站更容易的被搜索引擎收录，并且取得一个较为靠前的排名，让别人更容易地搜索到你，为自己的网站增加更多的曝光率与点击率。</p>
<p>&nbsp;</p>
<center>如下图所示，网站在直接搜索名字的情况下，排名第五</center>
<center>（排在前边的自然是Facebook，Linkin这种，希望有朝一日能干掉他们hhhh）</center>

<p><img src=".//Blog06/ggSearchResult_name.png" alt></p>
<p>&nbsp;</p>
<center>在搜索站内博客的情况下（全网无重复），排名第三</center>

<p><img src=".//Blog06/ggSearchResult_blog.png" alt></p>
<p>&nbsp;</p>
<center>在搜索网站Title的情况下，排名第一、第二</center>

<p><img src=".//Blog06/ggSearchResult_title.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>上边是优化后，进行Google搜索的结果展示。可以看到，无论是网站标题，还是站内二级博客，二级Tag，Google均对其进行了索引与收录。由于Baidu站长提交过程等待时间过长，我的网站还未被收录，这里就不进行展示了，不然还要等好久。下边就介绍一下我做了哪些优化</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="Baidu收录"><a href="#Baidu收录" class="headerlink" title="Baidu收录"></a>Baidu收录</h1><p>首先是Baidu收录。作为国内最大的搜索引擎，纵然千般不爱，还是要</p>
<p><img src=".//Blog06/ditou.png" alt></p>
<p>在提交链接到Baidu之前，首先需要购买一个属于自己的域名，不可以直接用Github Page提供的形如xxx.github.io这个域名。因为Github不允许Baidu的spider爬取自己的信息（例如Taobao）</p>
<p><img src=".//Blog06/Taobao.png" alt></p>
<p>注册完域名之后，绑定到自己的网站/Github Page的IP，这里就不赘述了，网上教程一大把。在浏览器测试可以访问后，就可以开始Baidu的优化了</p>
<p>&nbsp;</p>
<p>首先呢，要注册一个Baidu站长的账号，然后在站长工具里提交绑定了你网站的域名。由于我这边早就已经做完这个流程，这里就不进行复现了。各位可以直接<a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">点击此处</a>，提交链接到Baidu，如下图所示，填入自己网站URL，点击提交。</p>
<p><img src=".//Blog06/LinkSubmit_Baidu.png" alt></p>
<p>提交完之后，要证明网站的所有权，才能把其绑定到自己的Baidu账户下，方便日后通过站长工具进行分析、管理数据等操作。这里Baidu提供了三种验证方法，分别是<br>1.文件验证<br>2.html标签验证<br>3.CNAME验证</p>
<p>这里我选择的是CNAME验证，如下图：<br><img src=".//Blog06/CNAME_Baidu.png" alt><br>然后在域名服务提供商那里，添加一条解析记录就可以生效。我的域名服务提供商是腾讯云<br><img src=".//Blog06/CNAME.png" alt></p>
<p>好啦，到这里就算是收录完成。之后还可以通过站点地图进行优化，后边我会说到。接下来让我们进行Google的收录</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="Google收录"><a href="#Google收录" class="headerlink" title="Google收录"></a>Google收录</h1><p>Google的收录需要各位自行准备梯子，请自觉遵守中国大陆法律法规。<br>和Baidu一样，首先要准备一个Google账户，然后<a href="https://search.google.com/search-console/about#utm_source=zh-CN-wmxmsg&utm_medium=wmxmsg&utm_campaign=bm&authuser=0" target="_blank" rel="noopener">点此链接进入GoogleSearchConsole</a>，点击添加资源，如下图。如果你使用的域名服务提供商是GoDaddy或NameCheap，则可以通过左边的网域选项，去验证所有权。我的域名服务提供商是腾讯云，只能通过右边的选项进行验证，在右边横线处填入你网站的完整URL。<br><img src=".//Blog06/ggSearchConsole01.png" alt><br>然后点击继续，如下所示<br><img src=".//Blog06/ggSearchConsole02.png" alt><br>下载GoogleSearchConsole提供给你的那个html文件，将其<code>git push</code>到你网站的根目录下，然后<strong>回来点击验证</strong>，验证成功即可证明所有权，方便日后的分析、管理数据等操作。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="Site-Map"><a href="#Site-Map" class="headerlink" title="Site Map"></a>Site Map</h1><center>

<p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%AB%99%E5%9C%B0%E5%9C%96" target="_blank" rel="noopener">Sitemap的定义(Wikipedia)</a> || <a href="https://en.wikipedia.org/wiki/Site_map" target="_blank" rel="noopener">Definition of Sitemap (Wikipedia)</a></p>
</center>
SiteMap是一个描述网站架构的文件，它可以帮助搜索引擎spider更好的抓取网站，理解网站结构与内容，优化通过搜索引擎搜索到站内内容等等好处。其实顾名思义，网站地图，有了这个地图就可以随便逛你的网站，不会迷路。就像外出旅游，景区发给游客的指南一样，是不是一下子就理解了~~

<p>&nbsp;</p>
<p>那么第一步，我们要做的就是</p>
<h2 id="生成SiteMap"><a href="#生成SiteMap" class="headerlink" title="生成SiteMap"></a>生成SiteMap</h2><p>使用npm自动生成网站的SiteMap，然后将生成的SiteMap提交到Baidu和Google<br>执行如下两条命令，安装SiteMap生成插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save     </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<p>然后，在项目配置文件中，修改下图中的URL：<br><img src=".//Blog06/URLModify.png" alt><br>最后<code>Ctrl S</code>保存，<code>hexo g</code>重新生成，<code>hexo d</code>部署到服务器上即可。接下来就是</p>
<h2 id="提交到搜索引擎"><a href="#提交到搜索引擎" class="headerlink" title="提交到搜索引擎"></a>提交到搜索引擎</h2><h3 id="提交到Baidu"><a href="#提交到Baidu" class="headerlink" title="提交到Baidu"></a>提交到Baidu</h3><p>百度提供了三种提交的方式，分别是主动推送、自动推送、Sitemap。其中主动提交更新的效果比较好，并且一次设置好，以后就可以自动执行。<br><img src=".//Blog06/SiteMap_Baidu01.png" alt><br><img src=".//Blog06/SiteMap_Baidu02.png" alt></p>
<p>通过如下命令下载插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure>
<p>然后在项目配置文件中，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 100</span><br><span class="line">  host:  # 在百度站长平台中验证的域名</span><br><span class="line">  token:  # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure>
<p>并且依旧在项目配置文件中，如下添加一条deploy的type<br><img src=".//Blog06/SiteMap_Baidu03.png" alt></p>
<p>接着，是设置自动推送。在主题配置文件中，设置baidu_push: true，如下图<br><img src=".//Blog06/SiteMap_Baidu04.png" alt></p>
<p>然后修改如下路径文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_scripts&#x2F;baidu_push.swig</span><br></pre></td></tr></table></figure>
<p>添加代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.baidu_push %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> bp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> curProtocol = <span class="built_in">window</span>.location.protocol.split(<span class="string">':'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span> (curProtocol === <span class="string">'https'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        bp.src = <span class="string">'https://zz.bdstatic.com/linksubmit/push.js'</span>;        </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        bp.src = <span class="string">'http://push.zhanzhang.baidu.com/push.js'</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</span></span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最后回到Baidu站长平台，提交网站文件，如下图<br><img src=".//Blog06/SiteMap_Baidu05.png" alt></p>
<p>到此，Baidu的优化就算是告一段落。但是Baidu的收录特别慢，一般都得是半个月左右，耐心等待吧。</p>
<p>接下来就是</p>
<h3 id="提交到Google"><a href="#提交到Google" class="headerlink" title="提交到Google"></a>提交到Google</h3><p>提交到Google的方法和百度原理相同，过程简单很多。访问GoogleSearchConsole，然后添加即可，如下：<br><img src=".//Blog06/SiteMap_Google01.png" alt><br>Google的收录速度非常快，我部署完Baidu又部署Google，晚上10点才弄完。第二天早上7点醒来发现Google已经成功收录</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="网站内URL优化"><a href="#网站内URL优化" class="headerlink" title="网站内URL优化"></a>网站内URL优化</h1><p>Hexo默认博客的URL是<code>sitename/year/mounth/day/title</code>这样一个四级结构。结构越深越不利于搜索引擎的爬取，一般都以三级以下为较好的深度。</p>
<center>如下两图所示，优化后，这篇博客是一个二级目录，有助于搜索引擎爬取，搜索结果排名第三</center>

<p><img src=".//Blog06/InSiteURL.png" alt><br><img src=".//Blog06/ggSearchResult_blog.png" alt></p>
<p>具体优化步骤如下：<br>打开项目配置文件，找到<code>permalink</code>，如下第五行进行修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;ryanyhliu.com</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :title.html</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br></pre></td></tr></table></figure>
<p>之后<code>Ctrl S</code>保存，<code>hexo g</code>重新生成，<code>hexo d</code>部署到服务器上即可。</p>
<p>PS：我个人在此处遇到了一些别的问题，即图片无法显示。在浏览器端按下<code>F12</code>，打开开发人员工具，发现图片链接有误，生成静态页面的时候多加了一条反斜杠，如下图所示<br><img src=".//Blog06/PictureWrongURL.png" alt><br>我的解决方法也很暴力，直接在源码里多加一条反斜杠。<br><img src=".//Blog06/PictureWrongURLCode.png" alt><br>如果各位看官有什么更好的解决之道，望不吝赐教。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CDN的全称是Content Delivery NetWork，即内容分发网络。举个栗子，在大家刷抖音短视频时，向抖音服务器发送一条请求，抖音服务器基于推荐算法向你分发一条你可能感兴趣的短视频，那么大概的网络拓扑应该是如下图所示<br><img src=".//Blog06/example01.png" alt><br>可以看到，这么多客户端同时连接根服务器的话，根服务器需要一个十分可观的带宽进行支持，就好比很多车辆一起汇入主干路，那么这条主干路一定要十分宽敞。但是一条已经建成的马路，对其进行扩容是十分复杂的工程，并且考虑到高峰期，资源浪费十分严重，再就是较高的带宽的预算也非常高。以百度云盘为例，存储设施、电费等，均不及带宽服务费所占的支出，这也是为什么百度云盘限速厉害，吃相如此难看的本因。</p>
<p>&nbsp;</p>
<p>那么CDN的运作原理，如下图所示<br><img src=".//Blog06/example02.png" alt><br>在服务器与客户端之间，多了一层代理服务器。它们起到了分流的作用，就好比汇入主干路的匝道。也许你会想，那反正都要汇入主干路，根服务器的带宽要求岂不是并没有降低？这里又要涉及到CDN的另一个作用，就是本地缓存。这些代理服务器也是服务器，那么它们也一样拥有本地存储能力。抖音视频文件存储的时候会基于文件内容生成一个哈希串，哈希串是一个文件的ID，根据它可以判断出文件的一致性。比如用户A刷到了一条视频，这个视频首先从根服务器传输到代理服务器，再从代理服务器传输到用户手里。那么用户B也刷到这条视频的时候，还需要重复上述过程吗，并不是。该视频已经缓存在代理服务器中，直接从代理服务器给用户B进行分发即可，无需浪费根服务器带宽。就好比汽车加油，大家不是亲自去中东抗油桶，而是在家附近的加油站加油，是这样一个分销的过程。</p>
<p>好说了这么多，我们言归正传，介绍一下CDN技术是如何对我们的个人网页进行优化的吧。网站是基于Github Page搭建的，Github服务器架设在美国，由于GFW的原因，Github服务器在国内访问并不是很顺畅，而且还不稳定（参考Google）。我们这里采用CDN，无需连接到Github服务器，而是连接到CDN的服务器，不用担心GFW的影响。下面就开始正式的部署教程</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>我们选择的是<a href="https://www.cloudflare.com/zh-cn/" target="_blank" rel="noopener">Cloudflare</a>这个CDN提供商，它的主要优势就是：对个人<strong>免费</strong>。首先，就是点击该链接：<a href="https://dash.cloudflare.com/sign-up" target="_blank" rel="noopener">Cloudflare注册</a>，进行注册，然后添加站点<br><img src=".//Blog06/addSite.png" alt></p>
<p>方案选择免费方案<br><img src=".//Blog06/choosePlan.png" alt></p>
<p>然后添加DNS记录，这里Cloudflare会自动扫描你的域名解析。此处我们无需进行更改，点击继续即可（如下面两幅图，腾讯云控制台只有一条www的解析记录，会被Cloudflare扫描出来并自动添加）。由于我的<code>ryanyhliu.com</code>已经添加，这里就用另外一个域名做示范。<br><img src=".//Blog06/CloudTencent.png" alt><br><img src=".//Blog06/DNSRecord.png" alt></p>
<p>这里选择左边的默认方法<br><img src=".//Blog06/addSiteTemp.png" alt></p>
<p>然后来到下图<br><img src=".//Blog06/changeDNSServer.png" alt><br>这里我们需要在域名服务提供商处，修改域名的DNS解析服务器，改为图中Cloudflare提供的DNS服务器。由于我使用的是腾讯云，这里就用腾讯云配置进行示范。切换到腾讯云域名服务页面，点击管理（下图红色箭头指向）<br><img src=".//Blog06/DNS01.png" alt><br>进入如下页面，然后接着按图操作，点击修改，按照Cloudflare中给出的DNS服务器域名进行修改，用<code>rayne.ns.cloudflare.com</code> | <code>ridge.ns.cloudflare.com</code> 替换 <code>f1g1ns1.dnspod.net</code> | <code>f1g1ns2.dnspod.net</code>， 之后回到Cloudflare页面，点击“完成，检查名称服务器”<br><img src=".//Blog06/DNS02.png" alt><br><img src=".//Blog06/DNS03.png" alt><br>之后，来到下图所示页面<br><img src=".//Blog06/Setting.png" alt><br>把https打开，然后点击完成，即成功添加站点。稍后我们可以在Cloudflare管理页面进行更多设置。下图为Cloudflare站点管理页面<br><img src=".//Blog06/CloudflareConsole.png" alt><br>如图红框所示，还有很多很多的自定义配置可供选择，这里我就不展开细讲了，大家感兴趣的话可以自行搜索设置中的关键词去查询，修行在个人~（我实在是写吐了，不想写了，艹）</p>
<p>&nbsp;</p>
]]></content>
      <tags>
        <tag>运维</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Live2D让自己的头像动起来</title>
    <url>/Blog07.html</url>
    <content><![CDATA[<center>内含GIF图，网站没配置动态加载，载入较慢，见谅！</center>
&nbsp;
<a id="more"></a>

<p>最近由于疫情的原因，使用电脑摄像头的频率大幅提高。但是作为一名颜值主播，订阅没过500万是不能轻易露脸的(<a href="https://baike.baidu.com/item/%E4%B9%94%E7%A2%A7%E8%90%9D%E6%AE%BF%E4%B8%8B/23642693" target="_blank" rel="noopener">梗出处</a>)。我的解决方法就是生成一个属于自己的虚拟形象，废话不多说，先看效果图：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src=".//Blog07/preview.gif" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>正文开始。首先我们需要准备好FaceRig这款应用，<a href="https://store.steampowered.com/app/274920/FaceRig/" target="_blank" rel="noopener">该应用在Steam平台上有售</a>。其作用是通过2D摄像头进行实时的人脸识别追踪，通过识别并提取眼睛、眉毛、鼻子、嘴巴、脸部边缘的特征值，来将自己的面部行为映射到虚拟形象上。</p>
<p>这里放一张从网络上找来的效果预览图，非up本人，侵删。<br><img src=".//Blog07/facerigPreview.png" alt></p>
<p>下载好Facerig之后，还需要下载其Live2D支持的DLC拓展包，在Steam平台上搜索如下：<br><img src=".//Blog07/steamShortcut.png" alt><br>该DLC是一个对Live2D提供支持的插件，可以把通过Live2D创作好的虚拟形象导入到Facerig中使用。通过Live2D的官方开发工具，将做好的模型通过该DLC导入进Facerig中，就可以自动进行映射匹配。即Facerig会自动把用户创作的模型中的五官等元素进行链接与映射，用户只需在Live2D的工具中专心建模即可。</p>
<p>&nbsp;</p>
<p>接下来的部分就是如何通过Live2D技术来进行建模了，即创建一个虚拟形象。</p>
<p>首先我们需要去<a href="http://www.live2d.com/en/download/" target="_blank" rel="noopener">Live2D官网</a>下载建模工具。（向下滚动页面，最下方有测试版本可供免费使用）<br><img src=".//Blog07/Live2D_DownloadPage.png" alt></p>
<p>安装完毕之后，会显示两个图标。我们建模所使用到的是左边这个。<br><img src=".//Blog07/2Icons.png" alt></p>
<p>该软件是用来将模型中的各个部分对应匹配到五官，进而被Facerig识别，进行面部捕捉的。所以在使用这个软件之前，我们还需要搞一个模型。在这里我选择用我的头像进行仿制。<br><img src=".//Blog07/Avatar.png" alt></p>
<p>因为这个图画非常简单，所以在这里我使用的工具是PowerPoint。首先将原头像放进去，然后使用鼠标，像描字帖一样，画出一个拷贝版本，再把你描的这个新素材拖到旁边。这里需要注意的是，每一个部分（眼睛、嘴巴、脑袋）都是需要一笔成型。<br><img src=".//Blog07/PowerPoint.png" alt></p>
<p>由于Live2D的工具支持psd格式文件的导入。所以我们要把刚刚通过PowerPoint画出来的素材导入到PhotoShop中，再通过PhotoShop另存为psd格式的文件<br><img src=".//Blog07/PhotoShop.png" alt></p>
<p>保存之后，打开我们刚刚下载的Live2D工具，左上角File -&gt; Open，打开psd文件，工具会自动进行转制。<br><img src=".//Blog07/ToolImport.png" alt><br>导入成功之后如下图所示。<br><img src=".//Blog07/OverImport.png" alt></p>
<p>然后我们就可以在下图中的红色方框部分进行器官与模型的匹配了。<br><img src=".//Blog07/Live2D01.png" alt></p>
<p>这里我以整个头部的操作为例（其余部分操作类似，就不一个一个详细说了，大家自己摸索一下就能明白）。头部的运动分为XYZ三个轴方向上的运动，对应的是红色方框中最上边三行的绑定操作（如下图）。<br><img src=".//Blog07/Live2D02.png" alt></p>
<p>由于头部的特殊性，这里我们可以通过Live2D工具自带的功能，把面部<a href="http://sites.cybernoids.jp/cubism2_cn/modeler/deformer/placement-curve" target="_blank" rel="noopener">球面化</a>。免费版本的Live2D的<a href="https://baike.baidu.com/item/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86" target="_blank" rel="noopener">曲面细分</a>是有限制的，好在我们的模型比较简单，免费的也完全够用。先选中整个面部，再点击下图所示按钮，将选中的部分球面化。<br><img src=".//Blog07/Live2D03.png" alt></p>
<p>对了在这里还有个操作提示。与写代码相类似，Live2D里的模型也是分各个层次的。比如面部和身体为并列关系，而五官则隶属面部。当创建好球面模型后，我们可以在下图所示的左下部分红色方框中，通过拖动操作，进行更方便的层次结构调整<br><img src=".//Blog07/Live2D04.png" alt></p>
<p>面部球面化之后，会变成带有绿色标记点以及网格标记。通过拖动绿色标记点，就可以对面部进行球面变形。如下图所示，我们首先将角度X对应的轴拖到最左边，这里的映射关系是头部水平扭到最左边。然后再在右边的操作台上，通过调整绿色标记点，设定出你预想的模型对应的样子。<br><img src=".//Blog07/Live2D05.png" alt></p>
<p>将模型设置好了之后，便剩下了最后的步骤，将制作好的模型导入到Facerig中（此处再次提醒，不要忘了购买支持Live2D的DLC）。首先还是在Live2D工具中，左上角 File -&gt; Export for runtime -&gt; Export as moc3 file ，如下图：<br><img src=".//Blog07/ExportAsMoc3.png" alt></p>
<p>弹出的提示框我们不必改动，默认就好，然后点击OK即可。去输出的文件夹查看，一般为包含如下图的内容。<br><img src=".//Blog07/FilesInclude.png" alt></p>
<p>最后，将整个文件夹放到以下路径中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Steam\steamapps\common\FaceRig\Mod\VP\PC_Common\Objects</span><br></pre></td></tr></table></figure>
<p>与其它Facerig自带的默认模型放在一起，重启Facerig，在如下图所示的地方，即可找到你刚刚制作的新模型。<br><img src=".//Blog07/Facerig01.png" alt></p>
]]></content>
      <tags>
        <tag>Live2D</tag>
        <tag>Facerig</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title>祝各位国际劳动节快乐</title>
    <url>/Blog08.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<center>

<p>1886年5月1日，在美国举行了约35万人参加的罢工和示威游行<br>示威者要求改善劳动条件，实行<strong>八小时工作制</strong>。</p>
<p>&nbsp;</p>
<p>5月3日政府出动警察镇压，向人群开枪，杀害了四个人，受伤者无数</p>
<p>&nbsp;</p>
<p>5月4日各工会于干草市广场举行群众大会，遭警察包围。<br>突发爆炸事件，场面大乱，双方均死伤惨重</p>
<p>&nbsp;</p>
<p>事后警察与媒体咬定劳工领袖引起爆炸，以谋杀罪起诉八人<br>但其中五人均有不在场证明</p>
<p>&nbsp;</p>
<p>审判最后，<strong>一人被判十五年，二人被判无期，五人被判死刑</strong></p>
<p>&nbsp;</p>
<p>死刑之一工会领袖 奥古斯都·史比斯 临刑前说<br>“总有一天，我们的沉默，会远比今天你们所要压制的言论更为洪亮有力”</p>
<p>&nbsp;</p>
<p>1889年，巴黎第二次国际大会通过决议，将5月1日定为国际劳动节<br>要求全世界劳工共同努力，为实现八小时工作制而奋斗</p>
<p>&nbsp;</p>
<p>1894年，小罗斯福总统执政时，确立美国法律八小时工作制</p>
</center>]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存</title>
    <url>/Blog09.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p>Java内存（运行时数据区）<br>&nbsp;<br>在Java1.8之前长这样：<br><img src=".//Blog09/JVM01.png" alt><br>在Java1.8之后长这样：<br><img src=".//Blog09/JVM02.png" alt></p>
<p>二者最大的区别即图中蓝框所示的部分。在Java1.8之后，“方法区”改名为“元空间”，且放入直接内存（系统内存）中，不再属于JVM内存，相关介绍在本文方法区部分有讲。<del>大部分面试是以Java1.8之前的版本来进行考量</del>。</p>
<p>&nbsp;</p>
<p>接下来我们分别来介绍JVM内存组成部分。</p>
<h2 id="Java虚拟机栈（VM-Stack）"><a href="#Java虚拟机栈（VM-Stack）" class="headerlink" title="Java虚拟机栈（VM Stack）"></a>Java虚拟机栈（VM Stack）</h2><p>虚拟机栈是为Java字节码相关功能服务的。（我的理解是服务于Java代码相关部分）。</p>
<p>虚拟机栈<strong>结构</strong>包括</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口</li>
</ul>
<p>其中，局部变量表 负责存放各种数据类型（int，byte，char … ）以及对象的引用（reference类型）</p>
<p>虚拟机栈的<strong>生命周期</strong>由其线程生命周期决定（很好理解，虚拟机栈就是属于某个线程）。</p>
<p>虚拟机栈的两种异常：<br>1.StackOverFlowError：Stack不支持动态拓展，Stack 用完了<br>2.OutOfMemoryError  ：Stack  支持动态拓展，Memory用完了</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈只为Native方法服务（Native方法：非Java代码实现的方法）。</p>
<p>本地方法栈的<strong>结构</strong>、<strong>生命周期</strong>、<strong>异常</strong>与虚拟机栈类似，此处不赘述。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>堆是JVM中最大的一块内存，<strong>只存放</strong> 对象实例 以及 数组。</p>
<p><em>是垃圾收集器管理的主要区域，因此也被称为“GC堆”</em></p>
<p><em>从垃圾回收的角度看，堆可以划分为 新生代 和 老年代（至于我们常说的 永久代 并不属于堆内存）。新生代可继续划分为Eden区和Survivor区。Survivor区可继续划分为S0区和S1区。相关内容我会在Java垃圾回收篇详说，此处留白。</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区用来<strong>存储</strong> 类信息、常量、静态变量、编译后的代码 等数据。</p>
<p><em>实现方法区的内存也被称为 永久代（PermGen）</em></p>
<p>Java1.8之后，方法区变为元空间（MetaSpace），使用直接内存。这样做的好处是：<br><strong>不受JVM内存限制，不会触发OutOfMemoryError</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="常量池-（方法区的一部分）"><a href="#常量池-（方法区的一部分）" class="headerlink" title="常量池 （方法区的一部分）"></a>常量池 （方法区的一部分）</h2><p>常量池的<strong>结构</strong>如下：</p>
<ul>
<li>字面量<ul>
<li>文本字符串</li>
<li>final修饰的常量</li>
<li>基本数据类型的值</li>
<li><em>其它</em></li>
</ul>
</li>
<li>符号引用<ul>
<li>类和结构的完全限定名</li>
<li>字段名称 和 描述符</li>
<li>方法名称 和 描述符</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>内存</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/Blog10.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p>Java集合可大致分为两大类：Collection（单列集合）以及Map（双列集合）。<br>先来看一下大体的关系图（并没有完全列举，仅常用）</p>
<p>Collection：<br><img src=".//Blog10/Collection.png" alt></p>
<p>Map：<br><img src=".//Blog10/Map.png" alt></p>
<h2 id="1-接口介绍"><a href="#1-接口介绍" class="headerlink" title="1 接口介绍"></a>1 接口介绍</h2><p>接下来详细介绍一下上图各个接口。</p>
<h3 id="1-1-List"><a href="#1-1-List" class="headerlink" title="1.1 List"></a>1.1 List</h3><p>有序，可重复，可插入多个null值，元素都有索引。</p>
<h4 id="1-1-1-Vector"><a href="#1-1-1-Vector" class="headerlink" title="1.1.1 Vector"></a>1.1.1 Vector</h4><p>动态数组，同步（线程安全）</p>
<h5 id="1-1-1-1-Stack"><a href="#1-1-1-1-Stack" class="headerlink" title="1.1.1.1 Stack"></a>1.1.1.1 Stack</h5><p>继承自Vector，提供了5个额外方法，来实现堆栈操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push() pop() peek() empty() search()</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-ArrayList"><a href="#1-1-2-ArrayList" class="headerlink" title="1.1.2 ArrayList"></a>1.1.2 ArrayList</h4><p>动态数组，线程不安全，查找效率高（O(1)时间复杂度），增加、删除效率较低。</p>
<h4 id="1-1-3-LinkedList"><a href="#1-1-3-LinkedList" class="headerlink" title="1.1.3 LinkedList"></a>1.1.3 LinkedList</h4><p>双向循环链表，查找效率较低，增加、删除效率较高。</p>
<h3 id="1-2-Set"><a href="#1-2-Set" class="headerlink" title="1.2 Set"></a>1.2 Set</h3><p>（原则上）无序，不可重复，只允许有一个null值。</p>
<h4 id="1-2-1-HashSet"><a href="#1-2-1-HashSet" class="headerlink" title="1.2.1 HashSet"></a>1.2.1 HashSet</h4><p>基于HashMap实现</p>
<h5 id="1-2-1-1-LinkedHashSet"><a href="#1-2-1-1-LinkedHashSet" class="headerlink" title="1.2.1.1 LinkedHashSet"></a>1.2.1.1 LinkedHashSet</h5><p>基于LinkedHashMap实现，<strong>有序（维护各个元素插入时的顺序）</strong>。</p>
<h4 id="1-2-2-SortedSet"><a href="#1-2-2-SortedSet" class="headerlink" title="1.2.2 SortedSet"></a>1.2.2 SortedSet</h4><p>在Set的基础上，<strong>有序（维护各个元素值的大小的顺序）</strong>。</p>
<h5 id="1-2-2-1-TreeSet"><a href="#1-2-2-1-TreeSet" class="headerlink" title="1.2.2.1 TreeSet"></a>1.2.2.1 TreeSet</h5><p>在SortedSet的基础上，基于TreeMap实现。</p>
<h4 id="1-2-3-EnumSet"><a href="#1-2-3-EnumSet" class="headerlink" title="1.2.3 EnumSet"></a>1.2.3 EnumSet</h4><p>有序，不允许有null值，<strong>性能最好</strong></p>
<p>&nbsp;</p>
<h3 id="1-3-HashTable"><a href="#1-3-HashTable" class="headerlink" title="1.3 HashTable"></a>1.3 HashTable</h3><p>线程安全，结构为 数组+链表（同HashMap）。 K、V均不能为null。</p>
<h4 id="1-3-1-Properties"><a href="#1-3-1-Properties" class="headerlink" title="1.3.1 Properties"></a>1.3.1 Properties</h4><p>在HashTable的基础上，K、V均为字符串。</p>
<h3 id="1-4-HashMap"><a href="#1-4-HashMap" class="headerlink" title="1.4 HashMap"></a>1.4 HashMap</h3><p>线程不安全，无序，K、V均可为null，但K至多有一个可以为null。</p>
<ul>
<li>在Java1.8之前：由 数组+链表 组成。其中，数组为主体用于存放数据，链表负责解决哈希冲突（“拉链法”，效率为O(n)）。</li>
<li>在Java1.8之后：当 <strong>链表节点&gt;8 &amp;&amp; 数组长度&gt;64</strong> 时，结构自动转换为<strong>红黑树</strong>（效率变为O(logn)）。</li>
</ul>
<h4 id="1-4-1-LinkedHashMap"><a href="#1-4-1-LinkedHashMap" class="headerlink" title="1.4.1 LinkedHashMap"></a>1.4.1 LinkedHashMap</h4><p>有序，继承自HashMap。增加了一条双链表，可以保持KV对的顺序。</p>
<h3 id="1-5-SortedMap"><a href="#1-5-SortedMap" class="headerlink" title="1.5 SortedMap"></a>1.5 SortedMap</h3><p>只是一个Interface，TreeMap是其实现类。</p>
<h4 id="1-5-1-TreeMap"><a href="#1-5-1-TreeMap" class="headerlink" title="1.5.1 TreeMap"></a>1.5.1 TreeMap</h4><p>有序，K不能为null，V可以为null。默认按Key排序，也可以在创建TreeMap时，重写Comparator实现自定义排序。基于<strong>红黑树</strong>实现。</p>
<h3 id="1-6-WeakHashMap"><a href="#1-6-WeakHashMap" class="headerlink" title="1.6 WeakHashMap"></a>1.6 WeakHashMap</h3><p>一种改进的HashMap，对Key弱引用，若Key不再被使用则会被GC。</p>
<h2 id="2-知识点补充"><a href="#2-知识点补充" class="headerlink" title="2 知识点补充"></a>2 知识点补充</h2><h3 id="2-1-线程安全的集合类"><a href="#2-1-线程安全的集合类" class="headerlink" title="2.1 线程安全的集合类"></a>2.1 线程安全的集合类</h3><p>1.Vector：比ArrayList多了个同步机制。效率较低，不推荐使用。<br>2.Stack：栈数据结构，先进后出（FILO）。<br>3.HashTable：比HashMap多了同步机制（线程安全）。<br>4.Enumeration：枚举，作用相当于迭代器。</p>
<h3 id="2-2-创建只读集合"><a href="#2-2-创建只读集合" class="headerlink" title="2.2 创建只读集合"></a>2.2 创建只读集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collections.unmodifiableCollection(Collection C)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Iterator-迭代器"><a href="#2-3-Iterator-迭代器" class="headerlink" title="2.3 Iterator 迭代器"></a>2.3 Iterator 迭代器</h3><p>提供遍历任何Collection的接口，取代了Java集合框架中的Enumeration，并允许在迭代过程中删除元素（<code>Iterator.remove()</code>）。<br>其中，ListIterator在Iterator的基础上增加了 增，改 的功能，并且支持双向遍历。</p>
<p><strong>遍历一个List的三种方式</strong><br>1.for循环<br>2.Iterator<br>3.foreach（foreach的内部依然是Iterator。优点：简洁；缺点：只能遍历，不能删除）</p>
<h3 id="2-4-fail-fast-快速失败机制"><a href="#2-4-fail-fast-快速失败机制" class="headerlink" title="2.4 fail-fast 快速失败机制"></a>2.4 fail-fast 快速失败机制</h3><p>当Iterator <em>A</em> 在遍历集合时，某个线程 <em>B</em> 修改了集合的结构，此时会触发fail-fast机制。</p>
<p><em>属于java.util包</em></p>
<p><strong>原理</strong>：Iterator使用一个名为modCount的变量，实时计算集合内容。每当Iterator调用<code>hasNext()</code>/<code>next()</code>时，就把modCount的值与当前集合内容计算的值进行比对。若一致则继续运行，反之则抛出异常。</p>
<p><strong>解决</strong>：把涉及modCount的代码加上Synchronized修饰，或者使用CopyOnWriteArrayList替换ArrayList。</p>
<p>Iterator只能单向遍历，但是由于有了fail-fast的存在，使其比较安全。</p>
<h3 id="2-5-fail-safe-安全失败机制"><a href="#2-5-fail-safe-安全失败机制" class="headerlink" title="2.5 fail-safe 安全失败机制"></a>2.5 fail-safe 安全失败机制</h3><p>当对集合的结构做出改变时，fail-fast机制会抛出异常，而fail-safe不会。</p>
<p><em>属于java.util.concurrent包</em></p>
<p><strong>原理</strong>：fail-safe机制实质上会把集合的内容做一份拷贝，在拷贝出的副本集合上进行遍历操作。</p>
<p><strong>缺点</strong>：显而易见，需要另外的时空间开销，并且不能保证遍历的内容是实时（最新）的。</p>
<h3 id="2-6-Random-Access接口"><a href="#2-6-Random-Access接口" class="headerlink" title="2.6 Random Access接口"></a>2.6 Random Access接口</h3><p>用来标记List是否支持Random Access（随机访问）。即支持O(1)时间复杂度的查找，比如ArrayList就支持，LinkedList就不支持。</p>
<h3 id="2-7-Array-与-List-转换"><a href="#2-7-Array-与-List-转换" class="headerlink" title="2.7 Array 与 List 转换"></a>2.7 Array 与 List 转换</h3><p>Array -&gt; List:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.asList(arr)</span><br></pre></td></tr></table></figure>

<p>List -&gt; Array:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.toArray()</span><br></pre></td></tr></table></figure>

<h3 id="2-8-HashSet如何保证不重复"><a href="#2-8-HashSet如何保证不重复" class="headerlink" title="2.8 HashSet如何保证不重复"></a>2.8 HashSet如何保证不重复</h3><p>HashSet基于HashMap实现。即把Value存入HashMap的Key中（Key若相同，则覆盖）。使用<code>add()</code>时，相当于对Key进行比较（先<code>hashcode()</code>再<code>equals()</code>）。</p>
<h3 id="2-9-HashMap哈希冲突"><a href="#2-9-HashMap哈希冲突" class="headerlink" title="2.9 HashMap哈希冲突"></a>2.9 HashMap哈希冲突</h3><p>直接放我的笔记吧：<br><img src=".//Blog10/HashMap01.png" alt></p>
<h3 id="2-10-自动扩容"><a href="#2-10-自动扩容" class="headerlink" title="2.10 自动扩容"></a>2.10 自动扩容</h3><p>直接放我的笔记吧：<br><img src=".//Blog10/Expansion.png" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收机制（Garbage Collection）</title>
    <url>/Blog11.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p>垃圾回收是Java特有的功能，即由JVM主动判断回收那些程序不再需要的“垃圾”信息。</p>
<p>&nbsp;</p>
<h1 id="0-前记"><a href="#0-前记" class="headerlink" title="0 前记"></a>0 前记</h1><p>Java GC主要是对于<strong>堆内存</strong>来说的。此小节下面的部分，都是基于堆内存进行解释。所以，在这里我们先来看一下除了堆内存，其它地方（即方法区指代的PermGen）是如何GC的。这一部分相对独立，且重要性偏小，为了不影响大家的整体理解，就单独放在这里好了。</p>
<h2 id="0-1-方法区GC"><a href="#0-1-方法区GC" class="headerlink" title="0.1 方法区GC"></a>0.1 方法区GC</h2><p>如何判断一个类无用：<br>需要满足三点<br>1.所有实例都已经被回收（堆中无实例）。<br>2.加载该类的ClassLoader已经被回收。<br>3.该类对应的对象无引用（即无法通过反射访问该类的信息）。</p>
<h2 id="0-2-常量池GC"><a href="#0-2-常量池GC" class="headerlink" title="0.2 常量池GC"></a>0.2 常量池GC</h2><p>如何判断一个常量可被GC：<br>没有引用的常量就是废弃常量，可被GC。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="1-判断对象是否存活の算法"><a href="#1-判断对象是否存活の算法" class="headerlink" title="1 判断对象是否存活の算法"></a>1 判断对象是否存活の算法</h1><p>在发生GC前，要判断对象是否死亡，这里用到的判断方法有：</p>
<h2 id="1-1-引用计数法："><a href="#1-1-引用计数法：" class="headerlink" title="1.1 引用计数法："></a>1.1 引用计数法：</h2><p>   给对象添加一个计数器，每有一个地方引用它，计数器值+1；引用失效，计数器值-1。当计数器值==0时，对象死亡，不可能再被引用。<br>   Java不使用该方法，其存在<strong>问题：A与B相互引用时，A和B的计数器值恒大于等于1，永远无法被回收。</strong></p>
<h2 id="1-2-可达性分析算法："><a href="#1-2-可达性分析算法：" class="headerlink" title="1.2 可达性分析算法："></a>1.2 可达性分析算法：</h2><p>   首先通过一系列名为<strong>GC Roots</strong>的对象作为起点，从GC Roots向下搜索，走过的路径称为<strong>引用链（Reference Chain）</strong>。若待判断的对象与GC Roots之间不可达（无 Reference Chain），则为垃圾。</p>
<p>   <strong>可作为GC Roots的有：</strong><br>   1.虚拟机栈中引用的对象<br>   2.本地方法栈中引用的对象<br>   3.方法区常量引用的对象<br>   4.方法区类静态属性引用的对象</p>
<p>   如下图所示，Object 03、04、05 与 GC Roots 之间无 Reference Chain，故会被GC。而Object 01、02 会继续存活。<br><img src=".//Blog11/GCRoots.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="2-四种引用"><a href="#2-四种引用" class="headerlink" title="2 四种引用"></a>2 四种引用</h1><p>除了上述的两种算法外，Java GC还会通过引用的类型，来判断是否回收当前的对象。Java中的引用常分为如下四种类型：</p>
<ol>
<li>强引用：=，new就是强引用。GC Roots可达，不会被回收。</li>
<li>软引用：<strong>有用但非必须</strong>。OS在将要OutOfMemory之前，GC才会回收当前对象。</li>
<li>弱引用：OS无论Memory是否充足，只要GC，一定会回收当前对象。ThreadLocal就是弱引用。</li>
<li>虚引用：主要用来跟踪对象被垃圾回收的活动。</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="3-对象的访问定位（对象的引用）"><a href="#3-对象的访问定位（对象的引用）" class="headerlink" title="3 对象的访问定位（对象的引用）"></a>3 对象的访问定位（对象的引用）</h1><p>要GC某对象，首先要找到它。这里也是有两种算法可供了解：</p>
<ol>
<li>句柄法</li>
<li>直接指针</li>
</ol>
<p>这两种方法都是通过栈中的引用（reference），来操作堆上的对象。</p>
<h2 id="3-1-句柄法"><a href="#3-1-句柄法" class="headerlink" title="3.1 句柄法"></a>3.1 句柄法</h2><p>从堆内存中，划分出一块区域作为句柄池。</p>
<p><strong>reference中存放 对象的句柄地址</strong>。<br><strong>句柄中存放的是对象的 实例数据 与 类型数据 各自的地址</strong>。</p>
<p>句柄法<strong>优点</strong>：对象被移动时，只需修改 实例数据的指针，reference无需修改。</p>
<p><img src=".//Blog11/JUBING.jpg" alt></p>
<h2 id="3-2-直接指针"><a href="#3-2-直接指针" class="headerlink" title="3.2 直接指针"></a>3.2 直接指针</h2><p><em>HotSpot（全称为Java HotSpot Virtual Machine。一种较新版本的JVM，用来代替JIT，性能较高。是Sun JDK 和 Open JDK中自带的VM）使用该方法访问对象。</em></p>
<p><strong>reference中存放 对象的地址</strong>。<br><strong>对象中存放 实例数据 和 类型数据的地址</strong>。</p>
<p>直接指针<strong>优点</strong>：速度快，节省了一次指针定位的时间。</p>
<p><img src=".//Blog11/ZHIJIEZHIZHEN.jpg" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="4-垃圾回收の算法"><a href="#4-垃圾回收の算法" class="headerlink" title="4 垃圾回收の算法"></a>4 垃圾回收の算法</h1><p>对象的存亡判断，访问定位等问题已经解决了。万事俱备，亟待回收，接下来就该重头戏——GC算法登场！</p>
<h2 id="4-1-标记-清除算法"><a href="#4-1-标记-清除算法" class="headerlink" title="4.1 标记-清除算法"></a>4.1 标记-清除算法</h2><p>先标记，再清除。最基本的GC算法，其它算法都是由它改进而来。有两个缺点：</p>
<ol>
<li>效率低下</li>
<li>空间问题（碎片化：清理后的内存空间零零散散，不连续）</li>
</ol>
<h2 id="4-2-复制算法"><a href="#4-2-复制算法" class="headerlink" title="4.2 复制算法"></a>4.2 复制算法</h2><p>基于 4.1 标记-清除算法，一定程度的解决了上述两个问题。</p>
<p>它将内存分为大小相同的两块，每次使用其中一块。当该块内存满了便触发GC，将存活的对象整理到另外一半内存中，再将刚刚使用的内存完全擦除。下图可以强化理解：</p>
<p><img src=".//Blog11/FUZHI.jpg" alt></p>
<h2 id="4-3-标记-整理算法"><a href="#4-3-标记-整理算法" class="headerlink" title="4.3 标记-整理算法"></a>4.3 标记-整理算法</h2><p>同上，基于 4.1 标记-清除算法，一定程度的解决了上述两个问题。</p>
<p>标记之后，清除掉死亡的对象，再将存活的对象连续放在一起。</p>
<h2 id="4-4-分代垃圾回收算法"><a href="#4-4-分代垃圾回收算法" class="headerlink" title="4.4 分代垃圾回收算法"></a>4.4 分代垃圾回收算法</h2><p>目前的JVM都在用这个，综合了上述各算法，更好的提升了GC效率。</p>
<p><strong>Eden和Survivor一起使用复制算法，Tenured（老年代）使用标记-整理算法</strong></p>
<h3 id="4-4-1-划分"><a href="#4-4-1-划分" class="headerlink" title="4.4.1 划分"></a>4.4.1 划分</h3><p>堆内存分为 <code>年轻代（Young Generation）</code> 和 <code>老年代（Old Generation）</code><br>年轻代又分为 <code>Eden区</code> 和 <code>Survivor区</code><br>Survivor区又分为 <code>From区</code> 和 <code>To区</code>（HotSpot官方说法，民间常用的说法有分为S0/S1区，S1/S2区，都是一个意思）。</p>
<h3 id="4-4-2-垃圾回收——年轻代"><a href="#4-4-2-垃圾回收——年轻代" class="headerlink" title="4.4.2 垃圾回收——年轻代"></a>4.4.2 垃圾回收——年轻代</h3><p>对于年轻代的垃圾回收，有一个专属的名词<strong>“Minor GC”</strong>。</p>
<p><strong>触发条件</strong>：当新对象生成，且在Eden区分配内存失败时，触发Minor GC。</p>
<p>在整个年轻代中，每个对象都有一个“年龄”。每触发一次Minor GC，年龄+1，且会被挪动（拷贝）到另外一个Survivor区域。</p>
<p><strong>举个例子，假如，我们使用了Eden区和From Survivor区，那么To Survivor区就是空的。此时触发一次Minor GC，所有对象年龄+1。标记清除掉无引用的垃圾对象。再进行一次判断，若对象的年龄达到了15，则将其送入老年代。剩下的对象（存活，且年龄介于0和15之间），送入To Survivor区，此时From Survivor区就变成空的了。等到下一次触发Minor GC时，则再挪入From Survivor区中，空出To Survivor区，以此循环往复。</strong></p>
<h3 id="4-4-3-垃圾回收——老年代"><a href="#4-4-3-垃圾回收——老年代" class="headerlink" title="4.4.3 垃圾回收——老年代"></a>4.4.3 垃圾回收——老年代</h3><p>对于老年代的垃圾回收，也有”一个”专属的名词<strong>“Full GC”</strong>（也有称为Major GC的 =_= ）。</p>
<p><strong>触发条件</strong>：Full GC 通常由当前JVM的<strong>垃圾收集器</strong>来决定。</p>
<p><strong>每一次Full GC 通常都会触发至少一次 Minor GC</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="5-常见的垃圾收集器"><a href="#5-常见的垃圾收集器" class="headerlink" title="5 常见的垃圾收集器"></a>5 常见的垃圾收集器</h1><p>在 4.4.3 中提到了在何种情况下，会使用到垃圾收集器。</p>
<p><img src=".//Blog11/LAJISHOUJIQI.jpg" alt></p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>GC</tag>
      </tags>
  </entry>
</search>
