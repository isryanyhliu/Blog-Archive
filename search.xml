<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/Blog00.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>
<center>This post is created for test

<p>=_=</p>
<br>

<p>But, thanks for reading</p>
<p>Wish u a nice day</p>
</center>]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>与桂林某电子科技大学的校园网的防火墙斗智斗勇</title>
    <url>/Blog01.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>



<p>注：<br><br><em>请遵守中国大陆法律规定！</em><br><em>本文所记录的技术与过程仅为技术交流！切勿将其运用在其它地方！</em><br><em>若读者模仿并将其移用至别处，与本文作者无关！</em><br><em>感谢您的阅读和理解！</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近一直在玩一款名为部落冲突的手游，玩过的同学都知道，这个游戏到了中后期全靠肝。而作为一名优秀（懒得动手刷资源）的程序员，面对这种需要进行反复无意义的劳动时，就要有符合程序员核心价值观的意识——能用脚（本）解决的事情，就绝不动手！本来电脑开模拟器用脚本刷的开开心心，但是我最近由于某些个人原因，在一个月黑风高的夜晚，把电脑搬回了学校实验室。然后发现，游戏打开后就黑屏（进不去游戏）。<br><br><br><br>so——问题出现了，我们就要解决它！</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>首先要分析一下问题。<br></p>
<p>部落冲突打不开了，可能的原因有好几种：<br></p>
<p><strong>1.服务器坏了？</strong><br>没有。手机依然可以登陆；</p>
<p><strong>2.客户端坏了？</strong><br>没有。各个商店里的各个版本我都尝试过，不太可能出现这种事故<br><em>（当你觉得全世界有问题的时候，不妨先想想是不是自己的问题）</em></p>
<p>那么除却以上两点，出问题的可能就是网络了。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>打开模拟器的浏览器，发现一切正常。各种app也都可以使用，貌似只有部落冲突不能用。<br>到这里其实大家都应该有所感觉——会不会是这个游戏被屏蔽了呢？<br>验证的方法也很简单，如果学校要屏蔽游戏的话，那么首当其冲的肯定是</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src=".//Blog01/blog01_Gfat.png" alt><br><em>G胖：天天搞优惠亏钱就算了，到头来还要被屏蔽</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>果然<br><img src=".//Blog01/blog01_Steam.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>那么问题的所在就一目了然了——是学校的防火墙从中作梗！<br><img src=".//Blog01/blog01_Traitor.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>从原理上来说，我只要穿透这个防火墙就可以了<br>大家都听说过翻墙，只不过我现在要翻的是SchoolFireWall</p>
<p>既然要翻墙，那么首先需要搭一个代理服务器（俗称梯子）<br>我想了一圈，宿舍那边入户的网线没有屏蔽掉Steam，而且如果可以用的话，时延比起来外网的vps要小很多。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>于是我找到我宿舍的同学，让他帮我搭一个Linux虚拟机。<br>那么整体的网络架构应该是如下图所示的<br><img src=".//Blog01/blog01_Net.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>同学用的虚拟机是Windows10的子系统Ubuntu（Win10应用商店里的那个）<br>我查了一下，这个虚拟机和真机共享IP，即vmware的默认网卡模式（下图）<br><img src=".//Blog01/blog01_VMware.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>同学在虚拟机中部署好ssh并启动，把虚拟机用户帐密发给我，我在实验室进行连接并控制<br>这里为了避免与QQ抢端口，建议将其端口号改为23<br>那么网络架构图中右下角部分就算是打通了。</p>
<p>与此同时，我让同学使用windows cmd中的<strong>tracert ip</strong>命令，查询到了宿舍路由器的ip<br>（该命令可以跟踪数据包所经过的网关的ip）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>在下图这个例子中，<strong>第二个跃点为外网分配给路由器的ip</strong><br><img src=".//Blog01/blog01_TraceIP.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>我在实验室ping了一下第二个跃点（宿舍路由器）的ip，可以ping通<br>那么接下来只需要解决从路由器到同学的pc这一段即可</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>登陆路由器管理界面，找到高级设置中的DMZ功能（IP映射）<br>这个功能可以理解为将该路由器内网中的某一设备的ip映射到自己身上<br>也就是外网数据包发送到路由器的IP时，路由器会自动转发其到内网某一指定设备<br><img src=".//Blog01/blog01_MIwifi.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>最后，测试可以从实验室ssh连接到寝室的代理服务器。<br>当然，这个只是测试，总不能一直让同学开着虚拟机给我当代理服务器。<br>日后只需要用手里现成的树莓派3B就可以了。</p>
<p>代理服务器的问题已经解决了，我在电脑上信心满满的打开ShadowSocks客户端<br>连上代理服务器，切换为全局模式，双击steam图标，经过紧张的等待后</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src=".//Blog01/blog01_bqb.png" alt></p>
<p>还是上不去steam</p>
<p>很正常，生活嘛，总是起起落落落落落落落落落。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>经过我冷静的分析（划掉），以及google公司的鼎力相助<br></p>
<p>原来ShadowSocks客户端的全局模式并不是类似于VPN那种，可以代理本地的所有流量。<br>ShadowSocks的全局代理只是sock5代理，即只有http和socks数据会走代理</p>
<p>游戏有很多是udp，而大部分http都是用的tcp，所以我猜测steam和部落冲突的流量并没有走代理</p>
<p>解决方法是使用一个由<a href="https://www.zhihu.com/people/tao-neng-yi" target="_blank" rel="noopener">@AHaLa</a> 这位大佬提供的工具—— <a href="https://baike.baidu.com/item/proxifier/10859305" target="_blank" rel="noopener">proxifier_百度百科</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>通过网上的教程，使用ShadowSocks和proxifier将本机网络指定走代理（vpn）化之后<br>我兴奋的搓起了手，那感觉就像是革命胜利的前夕，不会再有压迫了！</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>但是，革命这种事情，总是一波三折<br></p>
<p>学校的防火墙除了防火墙最基本的IP封锁之外，还有另一个功能——DNS污染<br>在我尝试了指定DNS服务器以及修改hosts的方法发现二者均行不通</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>不过还好，proxifier提供了远程DNS解析<br><img src=".//Blog01/blog01_proxifierDNS.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>在看了几篇缺斤少两的博客之后，找到了一篇正确的<a href="https://lollogit.gitbooks.io/help/ssdian_nao_xi_tong_quan_ju_dai_li_jiao_cheng/shi_yong_proxifier_ba_ss_zhuan_wei_quan_ju_jia_su_.html" target="_blank" rel="noopener">proxifier和ShadowSocks将本地网络vpn化</a>教程（除了开启远程解析，还要把小飞机代理的的端口填入直连名单）最终，我成功的连上了steam网络！</p>
<p>看吧，只要思想不滑坡，方法总比困难多（wdnmd劳资csgo新买的皮肤还没好好看几眼）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>其实过程到这里就差不多结束了，但是吧~~</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><p>我来到实验室之后，发现昨天成功启动了脚本的部落冲突居然没有正常运行。仔细一看发现，我的电脑没网络了。一拍脑袋想到，学校的上网是要登陆的，每天晚上会把在线的强制下线。所以，要让它自动上线才可以</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>我google了一下相关的资料，在看过好多大神的思路之后，下载了一个名为<strong>Fiddler</strong>的抓包软件。Wireshark之前上计网的实验课倒是用过，但是比较复杂，杀鸡何用宰牛刀（其实是我忘了怎么用）<br><img src=".//Blog01/blog01_Fidder.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>通过抓取数据包，我发现学校的登陆系统是通过GET方式直接发送数据包，这就大大降低了难度，因为Get方式发送的话，用户名和密码是明文写在url里的。我发现登陆过程中一共产生了3个数据包，而第三个数据包就是名为login的登录信息，把它的url复制，存到txt里<br><img src=".//Blog01/blog01_TXT.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>只要把图中的DDDDD和upass换成自己的学号和密码就可以了，于是我手动注销，然后用浏览器直接访问改好的url。果然，并不需要经过登陆页面，直接就登陆成功了。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>那么接下来要做的，就是编写一个程序，实现这个功能。<br></p>
<p>大概的思路是，一直ping 8.8.8.8，如果可以ping通，则可以访问；如果不能ping通，则代表账户已被下线，需要访问指定的url。这里我使用python来实现。最后，再加上死循环让程序一直检测就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(os.system(<span class="string">'ping -c 8.8.8.8'</span>) == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Connect SUCCESS'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Connect FALSE'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        s = urllib2.urlopen(<span class="string">'此处为txt中修改好的URL'</span>)</span><br><span class="line">    <span class="keyword">except</span> urllib2.HTTPError, e:</span><br><span class="line">        <span class="keyword">print</span> e.code</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        ping()</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">do()</span><br></pre></td></tr></table></figure>


<p>本地测试之后发现一切正常，我便把它丢到树莓派上运行了，这样就可以保证我路由器下的所有子设备都可以保持7*24在线。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>大概就是这样了，第二天就可以看到全部刷满的资源（斜眼笑）。其实我本来想用树莓派直接搭全局代理，但是现在的资料貌似有点过时，树莓派的openwrt一直不出，lede的ss框架也不太好用，部署的证书都是过期的，pc基本没法用。如果走过路过的看官有相关资料的，还望指点迷津~</p>
<p>感谢阅读，以上</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>python</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>变量名是否占用内存</title>
    <url>/Blog03.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p><strong>想看结论的直接拖到最后</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>变量名究竟是否占用内存呢？</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>今天在网上看见这么一张图，里边有这么一句话不是很理解<br><img src=".//Blog03/blog03.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>为什么这样会浪费内存空间呢，我花了三个小时在网上查了些资料，整理了一下，具体如下：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>变量名编译后，变成一个内存地址</p>
<p>这个内存地址一般是直接存在于<font color="#00AB6F"><strong>代码段</strong></font>中</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>那么什么是<font color="#00AB6F"><strong>代码段</strong></font>呢？</p>
<p>一般把程序所占的主存空间分为（从低到高）：<br></p>
<p>1.<font color="#00AB6F"><strong>代码段</strong></font><br><br>2.数据段<br></p>
<p>3.栈<br><br>4.堆<br></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>其中，<font color="#00AB6F"><strong>代码段</strong></font>和数据段 是 <font color="#FF4900"><strong>编译期间</strong></font>就确定的</p>
<p>所以在整个程序编译期间，都占用内存空间</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>程序又分为<font color="#FF4900"><strong>编译期间</strong></font>和运行期间</p>
<p>变量名是在<font color="#FF4900"><strong>编译期间</strong></font>占用内存（所以那张截图里没说错）<br><br>而大多情况下，我们讨论的是运行期间</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>结论：</p>
<p>变量名 在  运行期间  是    不占内存的<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在  编译期间  是        占内存的</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>相关资料：<br><br><a href="http://blog.csdn.net/qianqin_2014/article/details/51114105" target="_blank" rel="noopener">http://blog.csdn.net/qianqin_2014/article/details/51114105</a><br><br><a href="http://bbs.csdn.net/topics/70123909" target="_blank" rel="noopener">http://bbs.csdn.net/topics/70123909</a></p>
]]></content>
      <tags>
        <tag>编译原理</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建基于Hexo的网站遇到的一些坑（2020.04）</title>
    <url>/Blog05.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p><em>非教程，仅用于记录自己搭建该网站遇到的一些问题和经验，以供大家参考，如有帮助不胜荣幸</em><br><em>本网站搭建于2020年4月份，Hexo版本号为 hexo-cli: 3.1.0; NexT主题版本为 5.1.4;</em><br><em>本文所记录的问题也是基于这个时间段、这个版本。不具有普遍适用性</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<font size="6">
<center>可以通过左侧导航栏，更方便的进行阅读</center>
</font>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="项目配置文件-amp-主题配置文件"><a href="#项目配置文件-amp-主题配置文件" class="headerlink" title="项目配置文件&amp;主题配置文件"></a>项目配置文件&amp;主题配置文件</h1><p><img src=".//Blog05/TwoConfigFiles.png" alt></p>
<p>如上图所示，整个项目里有两个配置文件( _config.yml )。它们分别位于项目根目录下、项目主题根目录下。项目根目录下的称其为项目配置文件、主题根目录下的称其为主题配置文件。在参考别人教程的时候切记不要改错了文件</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="边写博客边预览"><a href="#边写博客边预览" class="headerlink" title="边写博客边预览"></a>边写博客边预览</h1><p>我写博客使用的工具是VSCode，安装了三个插件如下：<br><img src=".//Blog05/MarkDownPlugin.png" alt></p>
<center>MarkDown All in One | Markdown Preview Github Styling | markdownlint</center>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>其中第二个插件是在VSCode里开一个侧栏，以提供MarkDown实时预览的，效果如下：<br><img src=".//Blog05/MarkDownPreview.png" alt><br>如果你仔细查看的话，可以看到，这个插件的显示效果与实际Hexo解析出的静态页面效果不一样。其中的图片与文字并未显示出换行效果，但是Hexo进行解析的时候会加上换行。Hexo有一个好处就是，可以进行实时预览，并不需要借助插件，具体的操作是: 首先<code>hexo s</code>启动本地Hexo服务，在浏览器输入<code>localhost:4000</code>打开页面。修改完当前MarkDown后，按下<code>Ctrl S</code>保存。之后在浏览器刷新当前页面即可。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="如何在电脑上进行移动端预览"><a href="#如何在电脑上进行移动端预览" class="headerlink" title="如何在电脑上进行移动端预览"></a>如何在电脑上进行移动端预览</h1><p>我使用的是基于chromium内核的Chrome和Edge这两款浏览器，对于它们而言，开启移动端预览的方法是相同的。打开浏览器，按<code>F12</code>，点击切换设备工具栏（如下图红色箭头指向）/ 也可以通过快捷键 <code>Ctrl + Shift + M</code>切换到移动端模式。通过左侧移动端预览上边的工具栏还可以自定义宽高的像素，选择预设机型，修改显示比例，修改网络环境和CPU（模拟老旧设备，弱网络环境）等选项<br><img src=".//Blog05/MobileMode.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="Hexo-常用命令的含义"><a href="#Hexo-常用命令的含义" class="headerlink" title="Hexo 常用命令的含义"></a>Hexo 常用命令的含义</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g      &#x2F;&#x2F;generate，保存后执行该命令，以重新生成文件</span><br><span class="line">hexo s      &#x2F;&#x2F;server，  启动本地服务器，进行预览</span><br><span class="line">hexo d      &#x2F;&#x2F;deploy，  部署本地项目到远程服务器</span><br><span class="line">hexo clean  &#x2F;&#x2F;清除本地静态文件（db.json，根目录public文件夹）</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="菜单显示、配置问题"><a href="#菜单显示、配置问题" class="headerlink" title="菜单显示、配置问题"></a>菜单显示、配置问题</h1><p>下图所示即为菜单部分<br><img src=".//Blog05/MenuDisplay.png" alt></p>
<p>我这个版本的NexT主题配置好了之后，默认只有Home、Category两个页面。这里有一个小坑就是<strong>配置页面时，修改的是主题配置文件</strong>，而不是项目配置文件。</p>
<p>执行命令<code>hexo new page &quot;PAGENAME&quot;</code>即可在目录<code>/source/</code>下新建一个菜单页的相关文件夹，里边便是该页的配置文件，如下图：<br><img src=".//Blog05/AboutmePage.png" alt></p>
<p>一开始我新建页面之后，点击菜单，跳转失败（找不到当前页面）。我看了一下浏览器的地址栏，发现跳转的时候URL会莫名其妙的多出来一个<code>%20%</code>，即多出来了一个空格。这其中的原因是在主题配置页面，把菜单配置中分隔符<code>||</code>左右的空格都给去掉就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 关于菜单示例配置</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F;||home</span><br><span class="line">  about: &#x2F;about&#x2F;||user</span><br><span class="line">  tags: &#x2F;tags&#x2F;||tags  </span><br><span class="line">  archives: &#x2F;archives&#x2F;||archive</span><br></pre></td></tr></table></figure>
<p>PS: 如果遇到Archives的ICON显示不出来的问题，不妨看看是不是archive多加了一个s，哈哈哈哈</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="粒子漂浮背景"><a href="#粒子漂浮背景" class="headerlink" title="粒子漂浮背景"></a>粒子漂浮背景</h1><p>效果图预览：<br><img src=".//Blog05/lizipiaofuPicture.png" alt><br>配置方法：执行该命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;canvas-nest</span><br></pre></td></tr></table></figure>

<p>然后在<strong>主题配置文件</strong>中，找到该项并如下设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure>

<p>但是如果你在移动端（真机）上预览，会发现这个背景会显得博客十分杂乱无章。这个的解决办法是要配置成<code>NexT v6.5.0</code>及其以上的版本，如果你进行了配置，可以通过以下的代码对粒子漂浮背景进行更多的设置。如果你像我这个憨憨一样用的是v5以下的版本，就只能暗自骂街了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # 是否在移动端显示</span><br><span class="line">  color: &#39;0,0,255&#39; # 动态背景中线条的 RGB 颜色</span><br><span class="line">  opacity: 0.5 # 动态背景中线条透明度</span><br><span class="line">  zIndex: -1 # 动态背景的 z-index 属性值</span><br><span class="line">  count: 99 # 动态背景中线条数量</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="如何默认展开多级标题"><a href="#如何默认展开多级标题" class="headerlink" title="如何默认展开多级标题"></a>如何默认展开多级标题</h1><p>在该路径文件下添加以下代码<br>路径： <code>/themes/next/source/css/_custom/custom.styl</code><br>代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//默认展开标题</span><br><span class="line"><span class="selector-class">.post-toc</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-child</span> &#123; </span><br><span class="line">    <span class="attribute">display</span>: block; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="侧边栏头像"><a href="#侧边栏头像" class="headerlink" title="侧边栏头像"></a>侧边栏头像</h1><p>效果图：<br><img src=".//Blog05/Avatar.png" alt><br>这个头像一定要是gif格式的，可以把png格式的图片直接修改拓展名变成gif，gif动图能否做头像我没尝试过。<br>把gif文件放在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;themes&#x2F;next&#x2F;source&#x2F;uploads&#x2F;</span><br></pre></td></tr></table></figure>
<p>目录下，然后修改<strong>主题配置文件</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">    avatar: &#x2F;uploads&#x2F;avatar.gif</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="网站运行时间统计"><a href="#网站运行时间统计" class="headerlink" title="网站运行时间统计"></a>网站运行时间统计</h1><p>效果图：<br><img src=".//Blog05/FooterRunTime.png" alt><br>在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig</span><br></pre></td></tr></table></figure>
<p>目录文件下，添加如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"timeDate"</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"times"</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">createtime</span><span class="params">()</span> </span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"04/06/2020 21:00:00"</span>);<span class="comment">//在此处修改你的建站时间，格式：月/日/年 时:分:秒</span></span></span><br><span class="line">        now.setTime(now.getTime()+250); </span><br><span class="line"><span class="javascript">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="built_in">Math</span>.floor(days); </span></span><br><span class="line"><span class="javascript">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="built_in">Math</span>.floor(hours); </span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">String</span>(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">"0"</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum); </span></span><br><span class="line"><span class="javascript">        mnum = <span class="built_in">Math</span>.floor(minutes); <span class="keyword">if</span>(<span class="built_in">String</span>(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">"0"</span> + mnum;&#125; </span></span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); </span><br><span class="line"><span class="javascript">        snum = <span class="built_in">Math</span>.round(seconds); <span class="keyword">if</span>(<span class="built_in">String</span>(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">"0"</span> + snum;&#125; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"timeDate"</span>).innerHTML = <span class="string">"我已在此等候你 "</span>+dnum+<span class="string">" 天 "</span>; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"times"</span>).innerHTML = hnum + <span class="string">" 小时 "</span> + mnum + <span class="string">" 分 "</span> + snum + <span class="string">" 秒"</span>; </span></span><br><span class="line">    &#125; </span><br><span class="line"><span class="actionscript">setInterval(<span class="string">"createtime()"</span>,<span class="number">250</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="关于版权声明、搞怪标题、站内搜索、网站访问量"><a href="#关于版权声明、搞怪标题、站内搜索、网站访问量" class="headerlink" title="关于版权声明、搞怪标题、站内搜索、网站访问量"></a>关于版权声明、搞怪标题、站内搜索、网站访问量</h1><p>请访问Yearito大神的博客<br><a href="http://yearito.cn/posts/hexo-advanced-settings.html" target="_blank" rel="noopener">Hexo搭建个人博客系列：进阶设置篇</a> </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="关于文章结束标记、看板娘、鼠标点击特效"><a href="#关于文章结束标记、看板娘、鼠标点击特效" class="headerlink" title="关于文章结束标记、看板娘、鼠标点击特效"></a>关于文章结束标记、看板娘、鼠标点击特效</h1><p>请访问Yearito大神的博客<br><a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="noopener">Hexo搭建个人博客系列：主题美化篇</a> </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
      <tags>
        <tag>Web</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>通过邻接表实现广度优先搜索（迷宫问题）</title>
    <url>/Blog04.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p><strong>“Talk is cheap. Show me the code.”  — Linus Torvalds</strong><br></p>
<p>直接上代码，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment">            问题：迷宫问题 </span></span><br><span class="line"><span class="comment">            算法：广度优先搜索 </span></span><br><span class="line"><span class="comment">         数据结构：邻接表 </span></span><br><span class="line"><span class="comment">***************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R 7 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Branch</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> row;</span><br><span class="line">	<span class="keyword">int</span> column;</span><br><span class="line"></span><br><span class="line">	_Branch * nextBranch;</span><br><span class="line">&#125;</span><br><span class="line">* Branch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Root</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> row;</span><br><span class="line">	<span class="keyword">int</span> column;</span><br><span class="line"></span><br><span class="line">	_Root * nextRoot;</span><br><span class="line">	_Branch * nextBranch;</span><br><span class="line">&#125;</span><br><span class="line">* Root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////全局变量 </span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[R][R];<span class="comment">//迷宫 </span></span><br><span class="line">Root treeRoot;<span class="comment">//树根 </span></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">1</span>;<span class="comment">//第几层 </span></span><br><span class="line"><span class="comment">/////////////////////// </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n---------------------------------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; R; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\t□"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\t%d"</span>, <span class="built_in">map</span>[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Branch <span class="title">findBranch</span><span class="params">(Root tempRoot, <span class="keyword">int</span> templevel)</span><span class="comment">//寻路 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Branch tempBranch = (struct _Branch *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct _Branch));	</span><br><span class="line">	<span class="keyword">int</span> tempRow = tempRoot -&gt; row;</span><br><span class="line">	<span class="keyword">int</span> tempColumn = tempRoot -&gt; column;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//up</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>[tempRow - <span class="number">1</span>][tempColumn] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tempBranch -&gt; row = tempRow - <span class="number">1</span>;</span><br><span class="line">		tempBranch -&gt; column = tempColumn;</span><br><span class="line">		<span class="built_in">map</span>[tempRow - <span class="number">1</span>][tempColumn] = templevel + <span class="number">1</span>;<span class="comment">//等于当前的层数加一 </span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> tempBranch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[tempRow - <span class="number">1</span>][tempColumn] == <span class="number">9</span>)<span class="comment">//出口是9 </span></span><br><span class="line">	&#123;</span><br><span class="line">		level = <span class="number">0</span>;<span class="comment">//找到了出口，把当前层数变成0，并返回NULL </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//right</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>[tempRow][tempColumn + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tempBranch -&gt; row = tempRow;</span><br><span class="line">		tempBranch -&gt; column = tempColumn + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">map</span>[tempRow][tempColumn + <span class="number">1</span>] = templevel + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> tempBranch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[tempRow][tempColumn + <span class="number">1</span>] == <span class="number">9</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		level = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//down</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>[tempRow + <span class="number">1</span>][tempColumn] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tempBranch -&gt; row = tempRow + <span class="number">1</span>;</span><br><span class="line">		tempBranch -&gt; column = tempColumn;</span><br><span class="line">		<span class="built_in">map</span>[tempRow + <span class="number">1</span>][tempColumn] = templevel + <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> tempBranch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[tempRow + <span class="number">1</span>][tempColumn] == <span class="number">9</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		level = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//left</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>[tempRow][tempColumn - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tempBranch -&gt; row = tempRow;</span><br><span class="line">		tempBranch -&gt; column = tempColumn - <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">map</span>[tempRow][tempColumn - <span class="number">1</span>] = templevel + <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> tempBranch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[tempRow][tempColumn - <span class="number">1</span>] == <span class="number">9</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		level = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addRoot</span><span class="params">(Branch tempBranch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Root tempRoot = (struct _Root *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(struct _Root));</span><br><span class="line">	Root tempBranchRoot = (struct _Root *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(struct _Root));</span><br><span class="line">	<span class="comment">//初始化 </span></span><br><span class="line">	&#123; </span><br><span class="line">		tempBranchRoot -&gt; row = tempBranch -&gt; row;</span><br><span class="line">		tempBranchRoot -&gt; column = tempBranch -&gt; column;</span><br><span class="line">		tempBranchRoot -&gt; nextBranch = <span class="literal">NULL</span>;</span><br><span class="line">		tempBranchRoot -&gt; nextRoot = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	tempRoot = treeRoot;</span><br><span class="line">	<span class="keyword">while</span> (tempRoot -&gt; nextRoot != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tempRoot = tempRoot -&gt; nextRoot;</span><br><span class="line">	&#125;</span><br><span class="line">	tempRoot -&gt; nextRoot = tempBranchRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createRoot</span><span class="params">(Root tempRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Branch tempBranch = (struct _Branch *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct _Branch));</span><br><span class="line">	tempBranch = tempRoot -&gt; nextBranch;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tempBranch != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		addRoot(tempBranch);<span class="comment">//把当前branch变成root </span></span><br><span class="line">		tempBranch = tempBranch -&gt; nextBranch;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Root tempRoot = (struct _Root *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(struct _Root));</span><br><span class="line">	Branch tempBranch = (struct _Branch *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct _Branch));</span><br><span class="line">	Branch lastBranch = (struct _Branch *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct _Branch));</span><br><span class="line">	</span><br><span class="line">	tempRoot = treeRoot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (level != <span class="number">0</span>)<span class="comment">//标识符，如果为0就代表找到了出口 </span></span><br><span class="line">	&#123;</span><br><span class="line">		tempBranch = findBranch(tempRoot, <span class="built_in">map</span>[tempRoot -&gt; row][tempRoot -&gt; column]);</span><br><span class="line">		<span class="comment">//为当前root建立branch </span></span><br><span class="line">		<span class="keyword">while</span> (tempBranch != <span class="literal">NULL</span>)<span class="comment">//如果还有branch </span></span><br><span class="line">		&#123;</span><br><span class="line">			tempBranch -&gt; nextBranch = <span class="literal">NULL</span>;</span><br><span class="line">			tempRoot -&gt; nextBranch = tempBranch;</span><br><span class="line">			lastBranch = tempBranch;</span><br><span class="line"></span><br><span class="line">			tempBranch = findBranch(tempRoot, <span class="built_in">map</span>[tempRoot -&gt; row][tempRoot -&gt; column]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (tempBranch != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				lastBranch -&gt; nextBranch = tempBranch;</span><br><span class="line">				lastBranch = tempBranch;</span><br><span class="line">				tempBranch = findBranch(tempRoot, <span class="built_in">map</span>[tempRoot -&gt; row][tempRoot -&gt; column]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		createRoot(tempRoot);<span class="comment">//把当前root的branch创建成root，放在表尾 </span></span><br><span class="line">		tempRoot = tempRoot -&gt; nextRoot;<span class="comment">//接着寻找下一个root </span></span><br><span class="line"></span><br><span class="line">		printMap();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">5</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">0</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">1</span>] =  <span class="number">1</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">2</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">3</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">4</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">5</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">3</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">2</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">3</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">4</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">1</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">2</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">3</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">4</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">5</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">4</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">5</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">2</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">3</span>] =  <span class="number">0</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">5</span>] =  <span class="number">9</span>; <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">map</span>[<span class="number">6</span>][<span class="number">0</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">2</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">3</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">4</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">5</span>] = <span class="number">-1</span>; <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">6</span>] = <span class="number">-1</span>; </span><br><span class="line">	printMap();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化根 </span></span><br><span class="line">	&#123;</span><br><span class="line">		treeRoot = (struct _Root *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(struct _Root));</span><br><span class="line">		treeRoot -&gt; nextRoot = <span class="literal">NULL</span>;</span><br><span class="line">		treeRoot -&gt; row = <span class="number">1</span>;</span><br><span class="line">		treeRoot -&gt; column = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	createTree();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>广度优先</tag>
        <tag>C语言</tag>
        <tag>数据结构</tag>
        <tag>迷宫问题</tag>
      </tags>
  </entry>
  <entry>
    <title>个人网站SEO及其它优化</title>
    <url>/Blog06.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>
<p>SEO，是Search Engine Optimization的缩写，中文意思是搜索引擎优化。通俗的说，就是如何让你自己的网站更容易的被搜索引擎收录，并且取得一个较为靠前的排名，让别人更容易地搜索到你，为自己的网站增加更多的曝光率与点击率。</p>
<p>&nbsp;</p>
<center>如下图所示，网站在直接搜索名字的情况下，排名第五</center>
<center>（排在前边的自然是Facebook，Linkin这种，希望有朝一日能干掉他们hhhh）</center>

<p><img src=".//Blog06/ggSearchResult_name.png" alt></p>
<p>&nbsp;</p>
<center>在搜索站内博客的情况下（全网无重复），排名第三</center>

<p><img src=".//Blog06/ggSearchResult_blog.png" alt></p>
<p>&nbsp;</p>
<center>在搜索网站Title的情况下，排名第一、第二</center>

<p><img src=".//Blog06/ggSearchResult_title.png" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>上边是优化后，进行Google搜索的结果展示。可以看到，无论是网站标题，还是站内二级博客，二级Tag，Google均对其进行了索引与收录。由于Baidu站长提交过程等待时间过长，我的网站还未被收录，这里就不进行展示了，不然还要等好久。下边就介绍一下我做了哪些优化</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="Baidu收录"><a href="#Baidu收录" class="headerlink" title="Baidu收录"></a>Baidu收录</h1><p>首先是Baidu收录。作为国内最大的搜索引擎，纵然千般不爱，还是要</p>
<p><img src=".//Blog06/ditou.png" alt></p>
<p>在提交链接到Baidu之前，首先需要购买一个属于自己的域名，不可以直接用Github Page提供的形如xxx.github.io这个域名。因为Github不允许Baidu的spider爬取自己的信息（例如Taobao）</p>
<p><img src=".//Blog06/Taobao.png" alt></p>
<p>注册完域名之后，绑定到自己的网站/Github Page的IP，这里就不赘述了，网上教程一大把。在浏览器测试可以访问后，就可以开始Baidu的优化了</p>
<p>&nbsp;</p>
<p>首先呢，要注册一个Baidu站长的账号，然后在站长工具里提交绑定了你网站的域名。由于我这边早就已经做完这个流程，这里就不进行复现了。各位可以直接<a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">点击此处</a>，提交链接到Baidu，如下图所示，填入自己网站URL，点击提交。</p>
<p><img src=".//Blog06/LinkSubmit_Baidu.png" alt></p>
<p>提交完之后，要证明网站的所有权，才能把其绑定到自己的Baidu账户下，方便日后通过站长工具进行分析、管理数据等操作。这里Baidu提供了三种验证方法，分别是<br>1.文件验证<br>2.html标签验证<br>3.CNAME验证</p>
<p>这里我选择的是CNAME验证，如下图：<br><img src=".//Blog06/CNAME_Baidu.png" alt><br>然后在域名服务提供商那里，添加一条解析记录就可以生效。我的域名服务提供商是腾讯云<br><img src=".//Blog06/CNAME.png" alt></p>
<p>好啦，到这里就算是收录完成。之后还可以通过站点地图进行优化，后边我会说到。接下来让我们进行Google的收录</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="Google收录"><a href="#Google收录" class="headerlink" title="Google收录"></a>Google收录</h1><p>Google的收录需要各位自行准备梯子，请自觉遵守中国大陆法律法规。<br>和Baidu一样，首先要准备一个Google账户，然后<a href="https://search.google.com/search-console/about#utm_source=zh-CN-wmxmsg&utm_medium=wmxmsg&utm_campaign=bm&authuser=0" target="_blank" rel="noopener">点此链接进入GoogleSearchConsole</a>，点击添加资源，如下图。如果你使用的域名服务提供商是GoDaddy或NameCheap，则可以通过左边的网域选项，去验证所有权。我的域名服务提供商是腾讯云，只能通过右边的选项进行验证，在右边横线处填入你网站的完整URL。<br><img src=".//Blog06/ggSearchConsole01.png" alt><br>然后点击继续，如下所示<br><img src=".//Blog06/ggSearchConsole02.png" alt><br>下载GoogleSearchConsole提供给你的那个html文件，将其<code>git push</code>到你网站的根目录下，然后<strong>回来点击验证</strong>，验证成功即可证明所有权，方便日后的分析、管理数据等操作。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="Site-Map"><a href="#Site-Map" class="headerlink" title="Site Map"></a>Site Map</h1><center>

<p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%AB%99%E5%9C%B0%E5%9C%96" target="_blank" rel="noopener">Sitemap的定义(Wikipedia)</a> || <a href="https://en.wikipedia.org/wiki/Site_map" target="_blank" rel="noopener">Definition of Sitemap (Wikipedia)</a></p>
</center>
SiteMap是一个描述网站架构的文件，它可以帮助搜索引擎spider更好的抓取网站，理解网站结构与内容，优化通过搜索引擎搜索到站内内容等等好处。其实顾名思义，网站地图，有了这个地图就可以随便逛你的网站，不会迷路。就像外出旅游，景区发给游客的指南一样，是不是一下子就理解了~~

<p>&nbsp;</p>
<p>那么第一步，我们要做的就是</p>
<h2 id="生成SiteMap"><a href="#生成SiteMap" class="headerlink" title="生成SiteMap"></a>生成SiteMap</h2><p>使用npm自动生成网站的SiteMap，然后将生成的SiteMap提交到Baidu和Google<br>执行如下两条命令，安装SiteMap生成插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save     </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<p>然后，在项目配置文件中，修改下图中的URL：<br><img src=".//Blog06/URLModify.png" alt><br>最后<code>Ctrl S</code>保存，<code>hexo g</code>重新生成，<code>hexo d</code>部署到服务器上即可。接下来就是</p>
<h2 id="提交到搜索引擎"><a href="#提交到搜索引擎" class="headerlink" title="提交到搜索引擎"></a>提交到搜索引擎</h2><h3 id="提交到Baidu"><a href="#提交到Baidu" class="headerlink" title="提交到Baidu"></a>提交到Baidu</h3><p>百度提供了三种提交的方式，分别是主动推送、自动推送、Sitemap。其中主动提交更新的效果比较好，并且一次设置好，以后就可以自动执行。<br><img src=".//Blog06/SiteMap_Baidu01.png" alt><br><img src=".//Blog06/SiteMap_Baidu02.png" alt></p>
<p>通过如下命令下载插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure>
<p>然后在项目配置文件中，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 100</span><br><span class="line">  host:  # 在百度站长平台中验证的域名</span><br><span class="line">  token:  # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure>
<p>并且依旧在项目配置文件中，如下添加一条deploy的type<br><img src=".//Blog06/SiteMap_Baidu03.png" alt></p>
<p>接着，是设置自动推送。在主题配置文件中，设置baidu_push: true，如下图<br><img src=".//Blog06/SiteMap_Baidu04.png" alt></p>
<p>然后修改如下路径文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_scripts&#x2F;baidu_push.swig</span><br></pre></td></tr></table></figure>
<p>添加代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.baidu_push %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> bp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> curProtocol = <span class="built_in">window</span>.location.protocol.split(<span class="string">':'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span> (curProtocol === <span class="string">'https'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        bp.src = <span class="string">'https://zz.bdstatic.com/linksubmit/push.js'</span>;        </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        bp.src = <span class="string">'http://push.zhanzhang.baidu.com/push.js'</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</span></span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最后回到Baidu站长平台，提交网站文件，如下图<br><img src=".//Blog06/SiteMap_Baidu05.png" alt></p>
<p>到此，Baidu的优化就算是告一段落。但是Baidu的收录特别慢，一般都得是半个月左右，耐心等待吧。</p>
<p>接下来就是</p>
<h3 id="提交到Google"><a href="#提交到Google" class="headerlink" title="提交到Google"></a>提交到Google</h3><p>提交到Google的方法和百度原理相同，过程简单很多。访问GoogleSearchConsole，然后添加即可，如下：<br><img src=".//Blog06/SiteMap_Google01.png" alt><br>Google的收录速度非常快，我部署完Baidu又部署Google，晚上10点才弄完。第二天早上7点醒来发现Google已经成功收录</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="网站内URL优化"><a href="#网站内URL优化" class="headerlink" title="网站内URL优化"></a>网站内URL优化</h1><p>Hexo默认博客的URL是<code>sitename/year/mounth/day/title</code>这样一个四级结构。结构越深越不利于搜索引擎的爬取，一般都以三级以下为较好的深度。</p>
<center>如下两图所示，优化后，这篇博客是一个二级目录，有助于搜索引擎爬取，搜索结果排名第三</center>

<p><img src=".//Blog06/InSiteURL.png" alt><br><img src=".//Blog06/ggSearchResult_blog.png" alt></p>
<p>具体优化步骤如下：<br>打开项目配置文件，找到<code>permalink</code>，如下第五行进行修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;ryanyhliu.com</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :title.html</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br></pre></td></tr></table></figure>
<p>之后<code>Ctrl S</code>保存，<code>hexo g</code>重新生成，<code>hexo d</code>部署到服务器上即可。</p>
<p>PS：我个人在此处遇到了一些别的问题，即图片无法显示。在浏览器端按下<code>F12</code>，打开开发人员工具，发现图片链接有误，生成静态页面的时候多加了一条反斜杠，如下图所示<br><img src=".//Blog06/PictureWrongURL.png" alt><br>我的解决方法也很暴力，直接在源码里多加一条反斜杠。<br><img src=".//Blog06/PictureWrongURLCode.png" alt><br>如果各位看官有什么更好的解决之道，望不吝赐教。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CDN的全称是Content Delivery NetWork，即内容分发网络。举个栗子，在大家刷抖音短视频时，向抖音服务器发送一条请求，抖音服务器基于推荐算法向你分发一条你可能感兴趣的短视频，那么大概的网络拓扑应该是如下图所示<br><img src=".//Blog06/example01.png" alt><br>可以看到，这么多客户端同时连接根服务器的话，根服务器需要一个十分可观的带宽进行支持，就好比很多车辆一起汇入主干路，那么这条主干路一定要十分宽敞。但是一条已经建成的马路，对其进行扩容是十分复杂的工程，并且考虑到高峰期，资源浪费十分严重，再就是较高的带宽的预算也非常高。以百度云盘为例，存储设施、电费等，均不及带宽服务费所占的支出，这也是为什么百度云盘限速厉害，吃相如此难看的本因。</p>
<p>&nbsp;</p>
<p>那么CDN的运作原理，如下图所示<br><img src=".//Blog06/example02.png" alt><br>在服务器与客户端之间，多了一层代理服务器。它们起到了分流的作用，就好比汇入主干路的匝道。也许你会想，那反正都要汇入主干路，根服务器的带宽要求岂不是并没有降低？这里又要涉及到CDN的另一个作用，就是本地缓存。这些代理服务器也是服务器，那么它们也一样拥有本地存储能力。抖音视频文件存储的时候会基于文件内容生成一个哈希串，哈希串是一个文件的ID，根据它可以判断出文件的一致性。比如用户A刷到了一条视频，这个视频首先从根服务器传输到代理服务器，再从代理服务器传输到用户手里。那么用户B也刷到这条视频的时候，还需要重复上述过程吗，并不是。该视频已经缓存在代理服务器中，直接从代理服务器给用户B进行分发即可，无需浪费根服务器带宽。就好比汽车加油，大家不是亲自去中东抗油桶，而是在家附近的加油站加油，是这样一个分销的过程。</p>
<p>好说了这么多，我们言归正传，介绍一下CDN技术是如何对我们的个人网页进行优化的吧。网站是基于Github Page搭建的，Github服务器架设在美国，由于GFW的原因，Github服务器在国内访问并不是很顺畅，而且还不稳定（参考Google）。我们这里采用CDN，无需连接到Github服务器，而是连接到CDN的服务器，不用担心GFW的影响。下面就开始正式的部署教程</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>我们选择的是<a href="https://www.cloudflare.com/zh-cn/" target="_blank" rel="noopener">Cloudflare</a>这个CDN提供商，它的主要优势就是：对个人<strong>免费</strong>。首先，就是点击该链接：<a href="https://dash.cloudflare.com/sign-up" target="_blank" rel="noopener">Cloudflare注册</a>，进行注册，然后添加站点<br><img src=".//Blog06/addSite.png" alt></p>
<p>方案选择免费方案<br><img src=".//Blog06/choosePlan.png" alt></p>
<p>然后添加DNS记录，这里Cloudflare会自动扫描你的域名解析。此处我们无需进行更改，点击继续即可（如下面两幅图，腾讯云控制台只有一条www的解析记录，会被Cloudflare扫描出来并自动添加）。由于我的<code>ryanyhliu.com</code>已经添加，这里就用另外一个域名做示范。<br><img src=".//Blog06/CloudTencent.png" alt><br><img src=".//Blog06/DNSRecord.png" alt></p>
<p>这里选择左边的默认方法<br><img src=".//Blog06/addSiteTemp.png" alt></p>
<p>然后来到下图<br><img src=".//Blog06/changeDNSServer.png" alt><br>这里我们需要在域名服务提供商处，修改域名的DNS解析服务器，改为图中Cloudflare提供的DNS服务器。由于我使用的是腾讯云，这里就用腾讯云配置进行示范。切换到腾讯云域名服务页面，点击管理（下图红色箭头指向）<br><img src=".//Blog06/DNS01.png" alt><br>进入如下页面，然后接着按图操作，点击修改，按照Cloudflare中给出的DNS服务器域名进行修改，用<code>rayne.ns.cloudflare.com</code> | <code>ridge.ns.cloudflare.com</code> 替换 <code>f1g1ns1.dnspod.net</code> | <code>f1g1ns2.dnspod.net</code>， 之后回到Cloudflare页面，点击“完成，检查名称服务器”<br><img src=".//Blog06/DNS02.png" alt><br><img src=".//Blog06/DNS03.png" alt><br>之后，来到下图所示页面<br><img src=".//Blog06/Setting.png" alt><br>把https打开，然后点击完成，即成功添加站点。稍后我们可以在Cloudflare管理页面进行更多设置。下图为Cloudflare站点管理页面<br><img src=".//Blog06/CloudflareConsole.png" alt><br>如图红框所示，还有很多很多的自定义配置可供选择，这里我就不展开细讲了，大家感兴趣的话可以自行搜索设置中的关键词去查询，修行在个人~（我实在是写吐了，不想写了，艹）</p>
<p>&nbsp;</p>
]]></content>
      <tags>
        <tag>Web</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Live2D让自己的头像动起来</title>
    <url>/Blog07.html</url>
    <content><![CDATA[<center>内含GIF图，网站没配置动态加载，载入较慢，见谅！</center>
&nbsp;
<a id="more"></a>

<p>最近由于疫情的原因，使用电脑摄像头的频率大幅提高。但是作为一名颜值主播，订阅没过500万是不能轻易露脸的(<a href="https://baike.baidu.com/item/%E4%B9%94%E7%A2%A7%E8%90%9D%E6%AE%BF%E4%B8%8B/23642693" target="_blank" rel="noopener">梗出处</a>)。我的解决方法就是生成一个属于自己的虚拟形象，废话不多说，先看效果图：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src=".//Blog07/preview.gif" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>正文开始。首先我们需要准备好FaceRig这款应用，<a href="https://store.steampowered.com/app/274920/FaceRig/" target="_blank" rel="noopener">该应用在Steam平台上有售</a>。其作用是通过2D摄像头进行实时的人脸识别追踪，通过识别并提取眼睛、眉毛、鼻子、嘴巴、脸部边缘的特征值，来将自己的面部行为映射到虚拟形象上。</p>
<p>这里放一张从网络上找来的效果预览图，非up本人，侵删。<br><img src=".//Blog07/facerigPreview.png" alt></p>
<p>下载好Facerig之后，还需要下载其Live2D支持的DLC拓展包，在Steam平台上搜索如下：<br><img src=".//Blog07/steamShortcut.png" alt><br>该DLC是一个对Live2D提供支持的插件，可以把通过Live2D创作好的虚拟形象导入到Facerig中使用。通过Live2D的官方开发工具，将做好的模型通过该DLC导入进Facerig中，就可以自动进行映射匹配。即Facerig会自动把用户创作的模型中的五官等元素进行链接与映射，用户只需在Live2D的工具中专心建模即可。</p>
<p>&nbsp;</p>
<p>接下来的部分就是如何通过Live2D技术来进行建模了，即创建一个虚拟形象。</p>
<p>首先我们需要去<a href="http://www.live2d.com/en/download/" target="_blank" rel="noopener">Live2D官网</a>下载建模工具。（向下滚动页面，最下方有测试版本可供免费使用）<br><img src=".//Blog07/Live2D_DownloadPage.png" alt></p>
<p>安装完毕之后，会显示两个图标。我们建模所使用到的是左边这个。<br><img src=".//Blog07/2Icons.png" alt></p>
<p>该软件是用来将模型中的各个部分对应匹配到五官，进而被Facerig识别，进行面部捕捉的。所以在使用这个软件之前，我们还需要搞一个模型。在这里我选择用我的头像进行仿制。<br><img src=".//Blog07/Avatar.png" alt></p>
<p>因为这个图画非常简单，所以在这里我使用的工具是PowerPoint。首先将原头像放进去，然后使用鼠标，像描字帖一样，画出一个拷贝版本，再把你描的这个新素材拖到旁边。这里需要注意的是，每一个部分（眼睛、嘴巴、脑袋）都是需要一笔成型。<br><img src=".//Blog07/PowerPoint.png" alt></p>
<p>由于Live2D的工具支持psd格式文件的导入。所以我们要把刚刚通过PowerPoint画出来的素材导入到PhotoShop中，再通过PhotoShop另存为psd格式的文件<br><img src=".//Blog07/PhotoShop.png" alt></p>
<p>保存之后，打开我们刚刚下载的Live2D工具，左上角File -&gt; Open，打开psd文件，工具会自动进行转制。<br><img src=".//Blog07/ToolImport.png" alt><br>导入成功之后如下图所示。<br><img src=".//Blog07/OverImport.png" alt></p>
<p>然后我们就可以在下图中的红色方框部分进行器官与模型的匹配了。<br><img src=".//Blog07/Live2D01.png" alt></p>
<p>这里我以整个头部的操作为例（其余部分操作类似，就不一个一个详细说了，大家自己摸索一下就能明白）。头部的运动分为XYZ三个轴方向上的运动，对应的是红色方框中最上边三行的绑定操作（如下图）。<br><img src=".//Blog07/Live2D02.png" alt></p>
<p>由于头部的特殊性，这里我们可以通过Live2D工具自带的功能，把面部<a href="http://sites.cybernoids.jp/cubism2_cn/modeler/deformer/placement-curve" target="_blank" rel="noopener">球面化</a>。免费版本的Live2D的<a href="https://baike.baidu.com/item/%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86" target="_blank" rel="noopener">曲面细分</a>是有限制的，好在我们的模型比较简单，免费的也完全够用。先选中整个面部，再点击下图所示按钮，将选中的部分球面化。<br><img src=".//Blog07/Live2D03.png" alt></p>
<p>对了在这里还有个操作提示。与写代码相类似，Live2D里的模型也是分各个层次的。比如面部和身体为并列关系，而五官则隶属面部。当创建好球面模型后，我们可以在下图所示的左下部分红色方框中，通过拖动操作，进行更方便的层次结构调整<br><img src=".//Blog07/Live2D04.png" alt></p>
<p>面部球面化之后，会变成带有绿色标记点以及网格标记。通过拖动绿色标记点，就可以对面部进行球面变形。如下图所示，我们首先将角度X对应的轴拖到最左边，这里的映射关系是头部水平扭到最左边。然后再在右边的操作台上，通过调整绿色标记点，设定出你预想的模型对应的样子。<br><img src=".//Blog07/Live2D05.png" alt></p>
<p>将模型设置好了之后，便剩下了最后的步骤，将制作好的模型导入到Facerig中（此处再次提醒，不要忘了购买支持Live2D的DLC）。首先还是在Live2D工具中，左上角 File -&gt; Export for runtime -&gt; Export as moc3 file ，如下图：<br><img src=".//Blog07/ExportAsMoc3.png" alt></p>
<p>弹出的提示框我们不必改动，默认就好，然后点击OK即可。去输出的文件夹查看，一般为包含如下图的内容。<br><img src=".//Blog07/FilesInclude.png" alt></p>
<p>最后，将整个文件夹放到以下路径中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Steam\steamapps\common\FaceRig\Mod\VP\PC_Common\Objects</span><br></pre></td></tr></table></figure>
<p>与其它Facerig自带的默认模型放在一起，重启Facerig，在如下图所示的地方，即可找到你刚刚制作的新模型。<br><img src=".//Blog07/Facerig01.png" alt></p>
]]></content>
      <tags>
        <tag>Live2D</tag>
        <tag>Facerig</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存</title>
    <url>/Blog09.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p>Java内存（运行时数据区）<br>&nbsp;<br>在Java1.8之前长这样：<br><img src=".//Blog09/JVM01.jpg" alt><br>在Java1.8之后长这样：<br><img src=".//Blog09/JVM02.jpg" alt></p>
<p>二者最大的区别即图中蓝框所示的部分。在Java1.8之后，“方法区”改名为“元空间”，且放入直接内存（系统内存）中，不再属于JVM内存，相关介绍在本文方法区部分有讲。<del>大部分面试是以Java1.8之前的版本来进行考量</del>。</p>
<p>&nbsp;</p>
<p>接下来我们分别来介绍JVM内存组成部分。</p>
<h2 id="Java虚拟机栈（VM-Stack）"><a href="#Java虚拟机栈（VM-Stack）" class="headerlink" title="Java虚拟机栈（VM Stack）"></a>Java虚拟机栈（VM Stack）</h2><p>虚拟机栈是为Java字节码相关功能服务的。（我的理解是服务于Java代码相关部分）。</p>
<p>虚拟机栈<strong>结构</strong>包括</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口</li>
</ul>
<p>其中，局部变量表 负责存放各种数据类型（int，byte，char … ）以及对象的引用（reference类型）</p>
<p>虚拟机栈的<strong>生命周期</strong>由其线程生命周期决定（很好理解，虚拟机栈就是属于某个线程）。</p>
<p>虚拟机栈的两种异常：<br>1.StackOverFlowError：Stack不支持动态拓展，Stack 用完了<br>2.OutOfMemoryError  ：Stack  支持动态拓展，Memory用完了</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈只为Native方法服务（Native方法：非Java代码实现的方法）。</p>
<p>本地方法栈的<strong>结构</strong>、<strong>生命周期</strong>、<strong>异常</strong>与虚拟机栈类似，此处不赘述。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>堆是JVM中最大的一块内存，<strong>只存放</strong> 对象实例 以及 数组。</p>
<p><em>是垃圾收集器管理的主要区域，因此也被称为“GC堆”</em></p>
<p><em>从垃圾回收的角度看，堆可以划分为 新生代 和 老年代（至于我们常说的 永久代 并不属于堆内存）。新生代可继续划分为Eden区和Survivor区。Survivor区可继续划分为S0区和S1区。相关内容我会在Java垃圾回收篇详说，此处留白。</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区用来<strong>存储</strong> 类信息、常量、静态变量、编译后的代码 等数据。</p>
<p><em>实现方法区的内存也被称为 永久代（PermGen）</em></p>
<p>Java1.8之后，方法区变为元空间（MetaSpace），使用直接内存。这样做的好处是：<br><strong>不受JVM内存限制，不会触发OutOfMemoryError</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="常量池-（方法区的一部分）"><a href="#常量池-（方法区的一部分）" class="headerlink" title="常量池 （方法区的一部分）"></a>常量池 （方法区的一部分）</h2><p>常量池的<strong>结构</strong>如下：</p>
<ul>
<li>字面量<ul>
<li>文本字符串</li>
<li>final修饰的常量</li>
<li>基本数据类型的值</li>
<li><em>其它</em></li>
</ul>
</li>
<li>符号引用<ul>
<li>类和结构的完全限定名</li>
<li>字段名称 和 描述符</li>
<li>方法名称 和 描述符</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>内存</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【杂记】 祝各位国际劳动节快乐</title>
    <url>/Blog08.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<center>

<p>1886年5月1日，在美国举行了约35万人参加的罢工和示威游行<br>示威者要求改善劳动条件，实行<strong>八小时工作制</strong>。</p>
<p>&nbsp;</p>
<p>5月3日政府出动警察镇压，向人群开枪，杀害了四个人，受伤者无数</p>
<p>&nbsp;</p>
<p>5月4日各工会于干草市广场举行群众大会，遭警察包围。<br>突发爆炸事件，场面大乱，双方均死伤惨重</p>
<p>&nbsp;</p>
<p>事后警察与媒体咬定劳工领袖引起爆炸，以谋杀罪起诉八人<br>但其中五人均有不在场证明</p>
<p>&nbsp;</p>
<p>审判最后，<strong>一人被判十五年，二人被判无期，五人被判死刑</strong></p>
<p>&nbsp;</p>
<p>死刑之一工会领袖 奥古斯都·史比斯 临刑前说<br>“总有一天，我们的沉默，会远比今天你们所要压制的言论更为洪亮有力”</p>
<p>&nbsp;</p>
<p>1889年，巴黎第二次国际大会通过决议，将5月1日定为国际劳动节<br>要求全世界劳工共同努力，为实现八小时工作制而奋斗</p>
<p>&nbsp;</p>
<p>1894年，小罗斯福总统执政时，确立美国法律八小时工作制</p>
</center>]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/Blog10.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p>Java集合可大致分为两大类：Collection（单列集合）以及Map（双列集合）。<br>先来看一下大体的关系图（并没有完全列举，仅常用）</p>
<p>Collection：<br><img src=".//Blog10/Collection.jpg" alt></p>
<p>Map：<br><img src=".//Blog10/Map.jpg" alt></p>
<h2 id="1-接口介绍"><a href="#1-接口介绍" class="headerlink" title="1 接口介绍"></a>1 接口介绍</h2><p>接下来详细介绍一下上图各个接口。</p>
<h3 id="1-1-List"><a href="#1-1-List" class="headerlink" title="1.1 List"></a>1.1 List</h3><p>有序，可重复，可插入多个null值，元素都有索引。</p>
<h4 id="1-1-1-Vector"><a href="#1-1-1-Vector" class="headerlink" title="1.1.1 Vector"></a>1.1.1 Vector</h4><p>动态数组，同步（线程安全）</p>
<h5 id="1-1-1-1-Stack"><a href="#1-1-1-1-Stack" class="headerlink" title="1.1.1.1 Stack"></a>1.1.1.1 Stack</h5><p>继承自Vector，提供了5个额外方法，来实现堆栈操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push() pop() peek() empty() search()</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-ArrayList"><a href="#1-1-2-ArrayList" class="headerlink" title="1.1.2 ArrayList"></a>1.1.2 ArrayList</h4><p>动态数组，线程不安全，查找效率高（O(1)时间复杂度），增加、删除效率较低。</p>
<h4 id="1-1-3-LinkedList"><a href="#1-1-3-LinkedList" class="headerlink" title="1.1.3 LinkedList"></a>1.1.3 LinkedList</h4><p>双向循环链表，查找效率较低，增加、删除效率较高。</p>
<h3 id="1-2-Set"><a href="#1-2-Set" class="headerlink" title="1.2 Set"></a>1.2 Set</h3><p>（原则上）无序，不可重复，只允许有一个null值。</p>
<h4 id="1-2-1-HashSet"><a href="#1-2-1-HashSet" class="headerlink" title="1.2.1 HashSet"></a>1.2.1 HashSet</h4><p>基于HashMap实现</p>
<h5 id="1-2-1-1-LinkedHashSet"><a href="#1-2-1-1-LinkedHashSet" class="headerlink" title="1.2.1.1 LinkedHashSet"></a>1.2.1.1 LinkedHashSet</h5><p>基于LinkedHashMap实现，<strong>有序（维护各个元素插入时的顺序）</strong>。</p>
<h4 id="1-2-2-SortedSet"><a href="#1-2-2-SortedSet" class="headerlink" title="1.2.2 SortedSet"></a>1.2.2 SortedSet</h4><p>在Set的基础上，<strong>有序（维护各个元素值的大小的顺序）</strong>。</p>
<h5 id="1-2-2-1-TreeSet"><a href="#1-2-2-1-TreeSet" class="headerlink" title="1.2.2.1 TreeSet"></a>1.2.2.1 TreeSet</h5><p>在SortedSet的基础上，基于TreeMap实现。</p>
<h4 id="1-2-3-EnumSet"><a href="#1-2-3-EnumSet" class="headerlink" title="1.2.3 EnumSet"></a>1.2.3 EnumSet</h4><p>有序，不允许有null值，<strong>性能最好</strong></p>
<p>&nbsp;</p>
<h3 id="1-3-HashTable"><a href="#1-3-HashTable" class="headerlink" title="1.3 HashTable"></a>1.3 HashTable</h3><p>线程安全，结构为 数组+链表（同HashMap）。 K、V均不能为null。</p>
<h4 id="1-3-1-Properties"><a href="#1-3-1-Properties" class="headerlink" title="1.3.1 Properties"></a>1.3.1 Properties</h4><p>在HashTable的基础上，K、V均为字符串。</p>
<h3 id="1-4-HashMap"><a href="#1-4-HashMap" class="headerlink" title="1.4 HashMap"></a>1.4 HashMap</h3><p>线程不安全，无序，K、V均可为null，但K至多有一个可以为null。</p>
<ul>
<li>在Java1.8之前：由 数组+链表 组成。其中，数组为主体用于存放数据，链表负责解决哈希冲突（“拉链法”，效率为O(n)）。</li>
<li>在Java1.8之后：当 <strong>链表节点&gt;8 &amp;&amp; 数组长度&gt;64</strong> 时，结构自动转换为<strong>红黑树</strong>（效率变为O(logn)）。</li>
</ul>
<h4 id="1-4-1-LinkedHashMap"><a href="#1-4-1-LinkedHashMap" class="headerlink" title="1.4.1 LinkedHashMap"></a>1.4.1 LinkedHashMap</h4><p>有序，继承自HashMap。增加了一条双链表，可以保持KV对的顺序。</p>
<h3 id="1-5-SortedMap"><a href="#1-5-SortedMap" class="headerlink" title="1.5 SortedMap"></a>1.5 SortedMap</h3><p>只是一个Interface，TreeMap是其实现类。</p>
<h4 id="1-5-1-TreeMap"><a href="#1-5-1-TreeMap" class="headerlink" title="1.5.1 TreeMap"></a>1.5.1 TreeMap</h4><p>有序，K不能为null，V可以为null。默认按Key排序，也可以在创建TreeMap时，重写Comparator实现自定义排序。基于<strong>红黑树</strong>实现。</p>
<h3 id="1-6-WeakHashMap"><a href="#1-6-WeakHashMap" class="headerlink" title="1.6 WeakHashMap"></a>1.6 WeakHashMap</h3><p>一种改进的HashMap，对Key弱引用，若Key不再被使用则会被GC。</p>
<h2 id="2-知识点补充"><a href="#2-知识点补充" class="headerlink" title="2 知识点补充"></a>2 知识点补充</h2><h3 id="2-1-线程安全的集合类"><a href="#2-1-线程安全的集合类" class="headerlink" title="2.1 线程安全的集合类"></a>2.1 线程安全的集合类</h3><p>1.Vector：比ArrayList多了个同步机制。效率较低，不推荐使用。<br>2.Stack：栈数据结构，先进后出（FILO）。<br>3.HashTable：比HashMap多了同步机制（线程安全）。<br>4.Enumeration：枚举，作用相当于迭代器。</p>
<h3 id="2-2-创建只读集合"><a href="#2-2-创建只读集合" class="headerlink" title="2.2 创建只读集合"></a>2.2 创建只读集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collections.unmodifiableCollection(Collection C)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Iterator-迭代器"><a href="#2-3-Iterator-迭代器" class="headerlink" title="2.3 Iterator 迭代器"></a>2.3 Iterator 迭代器</h3><p>提供遍历任何Collection的接口，取代了Java集合框架中的Enumeration，并允许在迭代过程中删除元素（<code>Iterator.remove()</code>）。<br>其中，ListIterator在Iterator的基础上增加了 增，改 的功能，并且支持双向遍历。</p>
<p><strong>遍历一个List的三种方式</strong><br>1.for循环<br>2.Iterator<br>3.foreach（foreach的内部依然是Iterator。优点：简洁；缺点：只能遍历，不能删除）</p>
<h3 id="2-4-fail-fast-快速失败机制"><a href="#2-4-fail-fast-快速失败机制" class="headerlink" title="2.4 fail-fast 快速失败机制"></a>2.4 fail-fast 快速失败机制</h3><p>当Iterator <em>A</em> 在遍历集合时，某个线程 <em>B</em> 修改了集合的结构，此时会触发fail-fast机制。</p>
<p><em>属于java.util包</em></p>
<p><strong>原理</strong>：Iterator使用一个名为modCount的变量，实时计算集合内容。每当Iterator调用<code>hasNext()</code>/<code>next()</code>时，就把modCount的值与当前集合内容计算的值进行比对。若一致则继续运行，反之则抛出异常。</p>
<p><strong>解决</strong>：把涉及modCount的代码加上Synchronized修饰，或者使用CopyOnWriteArrayList替换ArrayList。</p>
<p>Iterator只能单向遍历，但是由于有了fail-fast的存在，使其比较安全。</p>
<h3 id="2-5-fail-safe-安全失败机制"><a href="#2-5-fail-safe-安全失败机制" class="headerlink" title="2.5 fail-safe 安全失败机制"></a>2.5 fail-safe 安全失败机制</h3><p>当对集合的结构做出改变时，fail-fast机制会抛出异常，而fail-safe不会。</p>
<p><em>属于java.util.concurrent包</em></p>
<p><strong>原理</strong>：fail-safe机制实质上会把集合的内容做一份拷贝，在拷贝出的副本集合上进行遍历操作。</p>
<p><strong>缺点</strong>：显而易见，需要另外的时空间开销，并且不能保证遍历的内容是实时（最新）的。</p>
<h3 id="2-6-Random-Access接口"><a href="#2-6-Random-Access接口" class="headerlink" title="2.6 Random Access接口"></a>2.6 Random Access接口</h3><p>用来标记List是否支持Random Access（随机访问）。即支持O(1)时间复杂度的查找，比如ArrayList就支持，LinkedList就不支持。</p>
<h3 id="2-7-Array-与-List-转换"><a href="#2-7-Array-与-List-转换" class="headerlink" title="2.7 Array 与 List 转换"></a>2.7 Array 与 List 转换</h3><p>Array -&gt; List:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.asList(arr)</span><br></pre></td></tr></table></figure>

<p>List -&gt; Array:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.toArray()</span><br></pre></td></tr></table></figure>

<h3 id="2-8-HashSet如何保证不重复"><a href="#2-8-HashSet如何保证不重复" class="headerlink" title="2.8 HashSet如何保证不重复"></a>2.8 HashSet如何保证不重复</h3><p>HashSet基于HashMap实现。即把Value存入HashMap的Key中（Key若相同，则覆盖）。使用<code>add()</code>时，相当于对Key进行比较（先<code>hashcode()</code>再<code>equals()</code>）。</p>
<h3 id="2-9-HashMap哈希冲突"><a href="#2-9-HashMap哈希冲突" class="headerlink" title="2.9 HashMap哈希冲突"></a>2.9 HashMap哈希冲突</h3><p>直接放我的笔记吧：<br><img src=".//Blog10/HashMap01.jpg" alt></p>
<h3 id="2-10-自动扩容"><a href="#2-10-自动扩容" class="headerlink" title="2.10 自动扩容"></a>2.10 自动扩容</h3><p>直接放我的笔记吧：<br><img src=".//Blog10/Expansion.jpg" alt></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收机制（Garbage Collection）</title>
    <url>/Blog11.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p>垃圾回收是Java特有的功能，即由JVM主动判断回收那些程序不再需要的“垃圾”信息。</p>
<p>&nbsp;</p>
<h1 id="0-前记"><a href="#0-前记" class="headerlink" title="0 前记"></a>0 前记</h1><p>Java GC主要是对于<strong>堆内存</strong>来说的。此小节下面的部分，都是基于堆内存进行解释。所以，在这里我们先来看一下除了堆内存，其它地方（即方法区的永久代PermGen）是如何GC的。这一部分相对独立，且重要性偏小，为了不影响大家的整体理解，就单独放在这里好了。</p>
<h2 id="0-1-方法区GC"><a href="#0-1-方法区GC" class="headerlink" title="0.1 方法区GC"></a>0.1 方法区GC</h2><p>如何判断一个类无用：<br>需要满足三点<br>1.所有实例都已经被回收（堆中无实例）。<br>2.加载该类的ClassLoader已经被回收。<br>3.该类对应的对象无引用（即无法通过反射访问该类的信息）。</p>
<h2 id="0-2-常量池GC"><a href="#0-2-常量池GC" class="headerlink" title="0.2 常量池GC"></a>0.2 常量池GC</h2><p>如何判断一个常量可被GC：<br>没有引用的常量就是废弃常量，可被GC。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="1-判断对象是否存活の算法"><a href="#1-判断对象是否存活の算法" class="headerlink" title="1 判断对象是否存活の算法"></a>1 判断对象是否存活の算法</h1><p>在发生GC前，要判断对象是否死亡，这里用到的判断方法有：</p>
<h2 id="1-1-引用计数法："><a href="#1-1-引用计数法：" class="headerlink" title="1.1 引用计数法："></a>1.1 引用计数法：</h2><p>   给对象添加一个计数器，每有一个地方引用它，计数器值+1；引用失效，计数器值-1。当计数器值==0时，对象死亡，不可能再被引用。<br>   Java不使用该方法，其存在<strong>问题：A与B相互引用时，A和B的计数器值恒大于等于1，永远无法被回收。</strong></p>
<h2 id="1-2-可达性分析算法："><a href="#1-2-可达性分析算法：" class="headerlink" title="1.2 可达性分析算法："></a>1.2 可达性分析算法：</h2><p>   首先通过一系列名为<strong>GC Roots</strong>的对象作为起点，从GC Roots向下搜索，走过的路径称为<strong>引用链（Reference Chain）</strong>。若待判断的对象与GC Roots之间不可达（无 Reference Chain），则为垃圾。</p>
<p>   <strong>可作为GC Roots的有：</strong><br>   1.虚拟机栈中引用的对象<br>   2.本地方法栈中引用的对象<br>   3.方法区常量引用的对象<br>   4.方法区类静态属性引用的对象</p>
<p>   如下图所示，Object 03、04、05 与 GC Roots 之间无 Reference Chain，故会被GC。而Object 01、02 会继续存活。<br><img src=".//Blog11/GCRoots.jpg" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="2-四种引用"><a href="#2-四种引用" class="headerlink" title="2 四种引用"></a>2 四种引用</h1><p>除了上述的两种算法外，Java GC还会通过引用的类型，来判断是否回收当前的对象。Java中的引用常分为如下四种类型：</p>
<ol>
<li>强引用：=，new就是强引用。GC Roots可达，不会被回收。</li>
<li>软引用：<strong>有用但非必须</strong>。OS在将要OutOfMemory之前，GC才会回收当前对象。</li>
<li>弱引用：OS无论Memory是否充足，只要GC，一定会回收当前对象。ThreadLocal就是弱引用。</li>
<li>虚引用：主要用来跟踪对象被垃圾回收的活动。</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="3-对象的访问定位（对象的引用）"><a href="#3-对象的访问定位（对象的引用）" class="headerlink" title="3 对象的访问定位（对象的引用）"></a>3 对象的访问定位（对象的引用）</h1><p>要GC某对象，首先要找到它。这里也是有两种算法可供了解：</p>
<ol>
<li>句柄法</li>
<li>直接指针</li>
</ol>
<p>这两种方法都是通过栈中的引用（reference），来操作堆上的对象。</p>
<h2 id="3-1-句柄法"><a href="#3-1-句柄法" class="headerlink" title="3.1 句柄法"></a>3.1 句柄法</h2><p>从堆内存中，划分出一块区域作为句柄池。</p>
<p><strong>reference中存放 对象的句柄地址</strong>。<br><strong>句柄中存放的是对象的 实例数据 与 类型数据 各自的地址</strong>。</p>
<p>句柄法<strong>优点</strong>：对象被移动时，只需修改 实例数据的指针，reference无需修改。</p>
<p><img src=".//Blog11/JUBING.jpg" alt></p>
<h2 id="3-2-直接指针"><a href="#3-2-直接指针" class="headerlink" title="3.2 直接指针"></a>3.2 直接指针</h2><p><em>HotSpot（全称为Java HotSpot Virtual Machine。一种较新版本的JVM，用来代替JIT，性能较高。是Sun JDK 和 Open JDK中自带的VM）使用该方法访问对象。</em></p>
<p><strong>reference中存放 对象的地址</strong>。<br><strong>对象中存放 实例数据 和 类型数据的地址</strong>。</p>
<p>直接指针<strong>优点</strong>：速度快，节省了一次指针定位的时间。</p>
<p><img src=".//Blog11/ZHIJIEZHIZHEN.jpg" alt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="4-垃圾回收の算法"><a href="#4-垃圾回收の算法" class="headerlink" title="4 垃圾回收の算法"></a>4 垃圾回收の算法</h1><p>对象的存亡判断，访问定位等问题已经解决了。万事俱备，亟待回收，接下来就该重头戏——GC算法登场！</p>
<h2 id="4-1-标记-清除算法"><a href="#4-1-标记-清除算法" class="headerlink" title="4.1 标记-清除算法"></a>4.1 标记-清除算法</h2><p>先标记，再清除。最基本的GC算法，其它算法都是由它改进而来。有两个缺点：</p>
<ol>
<li>效率低下</li>
<li>空间问题（碎片化：清理后的内存空间零零散散，不连续）</li>
</ol>
<h2 id="4-2-复制算法"><a href="#4-2-复制算法" class="headerlink" title="4.2 复制算法"></a>4.2 复制算法</h2><p>基于 4.1 标记-清除算法，一定程度的解决了上述两个问题。</p>
<p>它将内存分为大小相同的两块，每次使用其中一块。当该块内存满了便触发GC，将存活的对象整理到另外一半内存中，再将刚刚使用的内存完全擦除。下图可以强化理解：</p>
<p><img src=".//Blog11/FUZHI.jpg" alt></p>
<h2 id="4-3-标记-整理算法"><a href="#4-3-标记-整理算法" class="headerlink" title="4.3 标记-整理算法"></a>4.3 标记-整理算法</h2><p>同上，基于 4.1 标记-清除算法，一定程度的解决了上述两个问题。</p>
<p>标记之后，清除掉死亡的对象，再将存活的对象连续放在一起。</p>
<h2 id="4-4-分代垃圾回收算法"><a href="#4-4-分代垃圾回收算法" class="headerlink" title="4.4 分代垃圾回收算法"></a>4.4 分代垃圾回收算法</h2><p>目前的JVM都在用这个，综合了上述各算法，更好的提升了GC效率。</p>
<p><strong>Eden和Survivor一起使用复制算法，Tenured（老年代）使用标记-整理算法</strong></p>
<h3 id="4-4-1-划分"><a href="#4-4-1-划分" class="headerlink" title="4.4.1 划分"></a>4.4.1 划分</h3><p>堆内存分为 <code>年轻代（Young Generation）</code> 和 <code>老年代（Old Generation）</code><br>年轻代又分为 <code>Eden区</code> 和 <code>Survivor区</code><br>Survivor区又分为 <code>From区</code> 和 <code>To区</code>（HotSpot官方说法，民间常用的说法有分为S0/S1区，S1/S2区，都是一个意思）。</p>
<h3 id="4-4-2-Minor-GC"><a href="#4-4-2-Minor-GC" class="headerlink" title="4.4.2 Minor GC"></a>4.4.2 Minor GC</h3><p>对于年轻代的垃圾回收，有一个专属的名词<strong>“Minor GC”</strong>。</p>
<p><strong>触发条件</strong>：当新对象生成，且在Eden区分配内存失败时，触发Minor GC。</p>
<p>在整个年轻代中，每个对象都有一个“年龄”。每触发一次Minor GC，年龄+1，且会被挪动（拷贝）到另外一个Survivor区域。</p>
<p><strong>举个例子，假如，我们使用了Eden区和From Survivor区，那么To Survivor区就是空的。此时触发一次Minor GC，所有对象年龄+1。标记清除掉无引用的垃圾对象。再进行一次判断，若对象的年龄达到了15，则将其送入老年代。剩下的对象（存活，且年龄介于0和15之间），送入To Survivor区，此时From Survivor区就变成空的了。等到下一次触发Minor GC时，则再挪入From Survivor区中，空出To Survivor区，以此循环往复。</strong></p>
<h3 id="4-4-3-Full-GC"><a href="#4-4-3-Full-GC" class="headerlink" title="4.4.3 Full GC"></a>4.4.3 Full GC</h3><p>对于老年代的垃圾回收，也有”一个”专属的名词<strong>“Full GC”</strong>（也有称为Major GC的 =_= ）。</p>
<p><strong>触发条件</strong>：Full GC 通常由当前JVM的<strong>垃圾收集器</strong>来决定。</p>
<p><strong>每一次Full GC 通常都会触发至少一次 Minor GC</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="5-常见的垃圾收集器"><a href="#5-常见的垃圾收集器" class="headerlink" title="5 常见的垃圾收集器"></a>5 常见的垃圾收集器</h1><p>在 4.4.3 中提到了在何种情况下，会使用到垃圾收集器。</p>
<p><img src=".//Blog11/LAJISHOUJIQI.jpg" alt></p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手与四次挥手</title>
    <url>/Blog12.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>先看一下我的笔记吧。</p>
<p>方框内表示的是Client/Server端的状态；中间连线表示数据包内的内容。<br><img src=".//Blog12/ThreewayHandshake.jpg" alt></p>
<p>三次握手中，“三次”的含义是建立TCP连接的过程中，一共有三个数据包。通过对三个数据包的合理使用，即可在C/S之间建立起可靠的数据传输通道。</p>
<p>如果要确认在C/S间建立起可靠连接，需要确认以下四点：</p>
<ol>
<li>Client端 发送功能正常</li>
<li>Client端 接收功能正常</li>
<li>Server端 发送功能正常</li>
<li>Server端 接收功能正常</li>
</ol>
<p>经过历史的淘汰，技术人员的精简，最后呈现在我们面前的就是这三个短小精悍的数据包。也就是说，三次握手的三个数据包，通过精妙的安排，分别证明了上述的四个功能，这三个数据包缺一不可。</p>
<p><strong>那么，这三个数据包的作用分别是：</strong><br><strong>第一个数据包（Server端成功接收）：证明了Client发送功能正常。</strong><br><strong>第二个数据包（Client端成功接收）：证明了Server接收功能正常、Server发送功能正常。</strong><br><strong>第三个数据包（Server端成功接收）：证明了Client接收功能正常。</strong></p>
<p>其它补充：<br>SYN与ACK对应，ACK的作用是确认收到（Acknowledgement）。<br>第三次握手在技术上就可以携带数据了（但实际上并没有）。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>还是先看一下我的笔记吧。</p>
<p>方框内表示的是Client/Server端的状态；中间连线表示数据包内的内容。<br><img src=".//Blog12/FourwayHandwave.jpg" alt></p>
<p>四次挥手的大概过程与原理，大家仔细分析一下上图就可以看明白，没什么特别之处值得详说。但是有一处值得注意：<strong>图中红色字体的部分</strong>。</p>
<p>让我们仔细来分析一下，为什么Client端的TIME WAIT状态需要等待2MSL（2个最大包存活时间）？</p>
<p>首先，我们看一下在这个时间点，TCP四次挥手此时正在发生的事情。</p>
<ol>
<li>若Server收到了第四个包，即可正常关闭连接。</li>
<li>若Server没有收到第四个包，则会重发一个ACK（第三个包）。</li>
</ol>
<p>在Server端发送完第三个包之后，需要收到Client端发送的第四个包，才会进入CLOSED状态。假如第四个包由于网络波动等原因loss掉（丢包），Server就会在等待了<strong>一段时间</strong>之后重新发送第三个包。这个Server端等待的<strong>一段时间</strong>，实际上就是一个包在网络中存活的最大时间（1MSL）。那么Server端重发的第三个包传递到Client端，又需要1MSL。这样加起来，总共需要2MSL。</p>
<p>所以，如果发生了坏情况（第四个包loss），需要经过2MSL（等待第四个包1MSL + 重发第三个包1MSL），Client端才会接收到Server端重发的第三个包。</p>
<p><font color="FF0000"><strong>补充！</strong></font><br>如果你在百度上检索这个2MSL，会发现很多回答都是“放空网络中的旧请求报文”。很多答案都闪烁其辞且相互抄袭，经过我个人查证，这种说法来源于《Unix网络编程卷1》中的一段解读：</p>
<p><em>“假设该Socket在关闭连接之后又打开，如果在关闭（四次挥手）的时候发生了波动（拥塞，延迟等），导致三次握手之后才收到上次连接的挥手数据包，就会产生不可预料的影响。为了避免出现这种情况，此处设置了2MSL用来放空所有四次挥手时的数据包。”</em></p>
<p><strong>但是，在原文中（下图红色批注）的原意是：2MSL足以放空！</strong>所以实际上，1MSL就足够进行数据包的放空。换句话说，2MSL并不是用来放空数据包，只是顺手做到了而已！</p>
<p><img src=".//Blog12/Unix01.jpg" alt></p>
<div style="text-align:right">——节选自《UNIX网络编程卷1》</div>

]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP与UDP</title>
    <url>/Blog13.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<h1 id="TCP与UDP的对比"><a href="#TCP与UDP的对比" class="headerlink" title="TCP与UDP的对比"></a>TCP与UDP的对比</h1><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">是否面向连接</th>
<th align="center">是否可靠</th>
<th align="center">传输形式</th>
<th align="center">传输效率</th>
<th align="center">所需资源</th>
<th align="center">应用场景</th>
<th align="center">支持</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">面向连接</td>
<td align="center">可靠</td>
<td align="center">字节流</td>
<td align="center">低</td>
<td align="center">多</td>
<td align="center">要求通信数据可靠</td>
<td align="center">单播</td>
</tr>
<tr>
<td align="center">UDP</td>
<td align="center">无连接</td>
<td align="center">不可靠</td>
<td align="center">数据报文段</td>
<td align="center">高</td>
<td align="center">少</td>
<td align="center">要求通信速率高</td>
<td align="center">广播、多播</td>
</tr>
</tbody></table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h1><ol>
<li>数据包编号排序。发送方给包编号，接收方给包排序。</li>
<li>校验和。若一组数据包校验和有误，则丢弃整组数据包。</li>
<li>接收端丢弃重复数据。</li>
<li>流量控制（滑动窗口算法）</li>
<li>拥塞控制</li>
<li>自动重传（ARQ协议）</li>
<li>超时重传</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="TCP-ARQ协议"><a href="#TCP-ARQ协议" class="headerlink" title="TCP ARQ协议"></a>TCP ARQ协议</h1><p>ARQ协议分为两种，一种是<code>停止等待ARQ</code>，另一种是<code>连续ARQ</code>。</p>
<p>停止等待ARQ：发完一个分组，便等待接收方确认。优点是简单，但是信道的利用率低，且等待时间长。</p>
<p>连续ARQ：连续发送分组，接收方对<strong>按序的最后一个发送</strong>进行确认。举个栗子，收到了编号为1，2，4，5的数据包，则需重发3，4，5数据包。优点是信道的利用率高，丢失不需要全部重传。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h1><p>拥塞：网络中分组过多，使得整体性能下降。</p>
<p>TCP拥塞控制：慢开始、拥塞避免、快重传+快恢复。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="TCP-粘包、拆包"><a href="#TCP-粘包、拆包" class="headerlink" title="TCP 粘包、拆包"></a>TCP 粘包、拆包</h1><p>举个栗子：Socket接收消息时，多个字符串粘在一起；一个字符串被拆开。</p>
<p>解决：可以用Netty自带的解码器解决。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="TCP-长连接-短连接，心跳机制"><a href="#TCP-长连接-短连接，心跳机制" class="headerlink" title="TCP 长连接/短连接，心跳机制"></a>TCP 长连接/短连接，心跳机制</h1><p>短连接：Client与Server读写完就关闭连接。<br>长连接：Client与Server读写玩不关闭连接。</p>
<p>若Client与Server<strong>保持长连接</strong>，且<strong>一段时间无数据交互</strong>，它们是无法发现对方是否仍然在线，即无法保证TCP的可靠性。为了解决这个问题，引入了心跳机制。</p>
<p><strong>心跳包</strong>：双方一段时间无交互时，一方就会主动发送一个特殊数据包，另一方收到之后也会回复一个特殊数据包。双方收到即可确认彼此在线（亦称作PING-PONG交互）。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h1><p>待深入。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
        <tag>网络协议</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java创建对象的过程（包含类加载）</title>
    <url>/Blog14.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p>在Java中，说到创建对象，我们大多数情况下使用的都是new指令。那么明面上一条new指令，暗地里经过JVM多少处理呢？</p>
<h1 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1 类加载检查"></a>1 类加载检查</h1><p>当JVM遇到一条new指令时，先检查其参数能否在常量池中定位到该类的符号引用。再检查该符号引用是否被加载过、解析过、初始化过。</p>
<p><em>注：符号引用相当于自定义的变量名等；引用除了符号引用以外，还有直接引用。直接引用指的是指针、偏移量之类的东西。</em></p>
<p><em>JVM并不是编译时，就加载所有类进内存。而是第一次运行某个类时才加载，且只加载这一次。</em></p>
<p>若有，则直接进行第二步分配内存。若没有，则执行<strong>类加载</strong>。</p>
<p>类加载的过程分为三步：<strong>加载 -&gt; 链接 -&gt; 初始化</strong>。<br>而链接又分为三步：<strong>验证 -&gt; 准备 -&gt; 解析</strong>。</p>
<p><em>加载和链接实际上是交叉进行的。加载未结束，链接已开始。</em></p>
<p><em>不妨多了解一点，<strong>类的生命周期</strong>：加载 -&gt; 链接 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</em></p>
<h2 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h2><p>加载这一步的内容是，把class文件装入内存。</p>
<p>在JVM中，内置的类加载器（ClassLoader）有三层，自顶向下分别是</p>
<ol>
<li>BootstrapClassLoader 启动类加载器（最顶层的ClassLoader，由C++实现）</li>
<li>ExtensionClassLoader 扩展类加载器</li>
<li>AppClassLoader 应用程序类加载器</li>
</ol>
<p>除了三层内置的ClassLoader以外，JVM还允许用户自定义类加载器（最底层）。</p>
<p>实际上，每一个类都有适合它的类加载器。如何快速的找到该类加载器？类加载器在协同工作时，默认会使用<strong>双亲委派模型（Parents Delegation Model）</strong>。<em>PS：这里的“双亲”指的是“父母那一辈”的意思。</em></p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>什么是双亲委派模型？在类加载的时候，首先把该请求委派给该父类加载器loadClass()处理。</p>
<p>因此所有的请求最后都会传到BootStrapClassLoader尝试处理。当父类加载器无法处理时，才会由自己处理。</p>
<p>若父类加载器为null，会自动把BootstrapClassLoader作为父类加载器。</p>
<p><strong>注意</strong>：类加载器的“父子”关系并不是继承，而是优先级！</p>
<p><strong>优点</strong>：可以避免类的重复加载，也保证Java核心API不被篡改（相同的类被不同的ClassLoader加载可能产生不同的类）。</p>
<p><em>如果不想使用双亲委派模型，可以自定义一个ClassLoader（继承自<code>java.lang.ClassLoader</code>），然后重写<code>loadClass()</code></em></p>
<h2 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h2><p>保证加载的字节流符合规范。</p>
<h2 id="1-3-准备"><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h2><p>为static变量（非实例变量）分配内存，并赋值。</p>
<h2 id="1-4-解析"><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h2><p>将常量池的符号引用替换为直接引用。</p>
<h2 id="1-5-初始化"><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h2><p>初始化static代码块，构造器等。</p>
<h1 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2 分配内存"></a>2 分配内存</h1><p>所需的内存大小，在类加载完成后，便可以确定。</p>
<p>内存分配的方式有两种，分别是<strong>指针碰撞法</strong>以及<strong>空闲列表法</strong></p>
<p><img src=".//Blog14/FENPEINEICUN.jpg" alt></p>
<p><strong>分配完内存，就会在内存上创建实例化对象。</strong></p>
<p>JVM在创建对象时，必须保证线程安全，通常用两种方法保证。</p>
<ol>
<li><p>CAS + 失败重试机制<br>CAS是乐观锁（乐观锁是一种思想，没有实际的锁。它假设不会出现冲突，所以不用加锁，直接去申请资源，失败就重试，直到成功为止）。CAS + 失败重试 可以保证操作的原子性，从而线程安全。</p>
</li>
<li><p>TLAB<br>全称ThreadLocalAllocBuffer，于 HotSpot1.6 引入，原理与指针碰撞法类似。在每个线程初始化时，同时申请一块指定大小的内存绑定给它。当线程需要内存时，就在自己的这块内存上分配，若容量不够，再去Eden区正常申请。<strong>优点</strong>：每个线程都有自己的专属指针，性能高。<img src=".//Blog14/TLAB.jpg" alt></p>
</li>
</ol>
<h1 id="3-初始化零值"><a href="#3-初始化零值" class="headerlink" title="3 初始化零值"></a>3 初始化零值</h1><p>分配内存完成后，要把这些内存初始化为0。<br><strong>所以成员变量可以不用初始化</strong></p>
<h1 id="4-设置对象头"><a href="#4-设置对象头" class="headerlink" title="4 设置对象头"></a>4 设置对象头</h1><p>初始化零值后，JVM要对对象实例进行设置。例如：</p>
<ol>
<li>该对象是哪个类的实例</li>
<li>如何找到该类的元数据</li>
<li>对象的HashCode</li>
<li>对象的GC年龄</li>
<li>锁状态标识</li>
</ol>
<p>这些信息都存放在对象头中。<em>PS：实例对象分为三个部分：对象头、实例数据、对齐填充（非必须）</em></p>
<h1 id="5-执行init-方法"><a href="#5-执行init-方法" class="headerlink" title="5 执行init()方法"></a>5 执行init()方法</h1><p>从JVM的角度来看，执行完上述4步，一个新对象已经产生。</p>
<p>执行完new指令后紧接着执行init()，才能完成对象实例的初始化（成员变量、成员方法等）。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>对象创建</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP相关 &amp;&amp; 对称/非对称加密简述</title>
    <url>/Blog15.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p>HTTP的底层是TCP，所以，TCP的一些特性在HTTP中得以保留。由于TCP中存在长连接与短连接，所以HTTP中也存在长连接与短连接。</p>
<h1 id="HTTP的长连接"><a href="#HTTP的长连接" class="headerlink" title="HTTP的长连接"></a>HTTP的长连接</h1><p>HTTP的长连接是基于TCP长连接做出的封装处理。HTTP长连接我们称之为<strong>Keep-Alive机制</strong>，其内容是：若长连接在2个小时（保活定时）内无任何反应，Server便向Client发送探测报文段，此时可能有4种结果：</p>
<ol>
<li><p>Client正常运行，且正常响应：<br>则Server保活定时复位（Reset）。</p>
</li>
<li><p>Client崩溃/重启，，无法响应：<br>Server继续每隔75秒发送一次探测报文段，共发送10次。若Client仍然没有响应，则关闭连接（CLOSED）。</p>
</li>
<li><p>Client崩溃后重启，一开始无响应，后来正常：<br>重启连接（连接已经中断，物是人非）。</p>
</li>
<li><p>Client正常运行，但探测报文段不可达（Client无响应）：<br>同第二点。</p>
</li>
</ol>
<h1 id="HTTP的短连接"><a href="#HTTP的短连接" class="headerlink" title="HTTP的短连接"></a>HTTP的短连接</h1><p>HTTP的短连接实际上是由于HTTP的特性（无连接）决定的。</p>
<p>所以，让我们引入HTTP的两个特性：无连接、无状态。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="HTTP是无连接的"><a href="#HTTP是无连接的" class="headerlink" title="HTTP是无连接的"></a>HTTP是无连接的</h1><p>每次只处理一个请求，处理完（收到Client应答）就断开。<br><strong>解决</strong>：Keep-Alive机制。</p>
<h1 id="HTTP是无状态的"><a href="#HTTP是无状态的" class="headerlink" title="HTTP是无状态的"></a>HTTP是无状态的</h1><p>每一次打开网页都完全独立。</p>
<p><strong>解决</strong>：</p>
<ol>
<li><p>Cookie：<br>存储在浏览器（Bowser）中，由Server生成<br>下一次请求该网站时，会把该Cookie发送给Server<br>不安全（在Server之外被非法读写）</p>
</li>
<li><p>Session<br>存储在Server，较安全<br>但是Server需要Client提供Session_id才能找到对应Session<br>Session_id通常使用Cookie存储</p>
</li>
<li><p>Token<br>可抵抗<a href="https://zh.wikipedia.org/zh/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">CSRF（跨站请求伪造）</a> </p>
</li>
<li><p>JWT</p>
</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTP的端口默认是80；HTTPS则是443。</p>
<p>HTTP基于TCP，明文传输；HTTPS基于HTTP + <strong>SSL</strong>，通过对称加密与非对称加密传输。下面我顺便简单介绍一下对称加密以及非对称加密，不感兴趣的同学可以直接跳过此部分。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>只有一个密钥，同时负责加密、解密，很好理解。</p>
<p><strong>常见算法</strong>：DES、AES等。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>有成对的密钥，称为 公钥 + 私钥，<strong>无法相互推导</strong>。一个加密，另一个解密。</p>
<p><strong>常见算法</strong>：RSA、DSA等。</p>
<p>这里举个栗子，强化大家的理解，是一个非常有趣的数学算法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，我们需要知道这样一件事：</span><br><span class="line"></span><br><span class="line">一个8位数，与 4 0000 0001 做乘法运算，</span><br><span class="line">得出的运算结果的后八位，就是那个8位数的值。</span><br><span class="line"></span><br><span class="line">比如 12345678 * 400000001 &#x3D; 4938271212345678</span><br><span class="line"></span><br><span class="line">好了，准备完成。接下来，就是非对称加密的部分了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server取其任意一对因数，比如 19801 与 20201</span><br><span class="line">（19801 * 20201 &#x3D; 400000001）</span><br><span class="line"></span><br><span class="line">我们设公钥为 19801， 私钥为 20201</span><br><span class="line">私钥存储在Server中，严格确保不外泄</span><br><span class="line">把公钥公开到网络中，并且附送上加密算法：</span><br><span class="line"></span><br><span class="line">密文 * 公钥，再取其后八位</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设，Client A想要传输内容为“12345678”的数据包给Server</span><br><span class="line">Client A获取到Server公开的公钥 19801</span><br><span class="line">12345678 * 19801 &#x3D; 244456770078，取后八位56770078</span><br><span class="line">Client A将56770078传输给Server</span><br><span class="line"></span><br><span class="line">在Client A向Server传输56770078时</span><br><span class="line">Client B通过抓包解包等技术手段，获取到该加密内容56770078</span><br><span class="line">由于加密算法是一个有损算法（舍弃了前4位）</span><br><span class="line">所以Client B即便知道加密过程，也无法还原数据</span><br><span class="line"></span><br><span class="line">好，此时Server也获取到了Client A的数据包</span><br><span class="line">Server 把 密文 * 私钥</span><br><span class="line">（56770078 * 20201 &#x3D; 1146812345678）</span><br><span class="line">再取其后8位，得到原文“12345678”</span><br></pre></td></tr></table></figure>
<p>怎么样，是不是非常简单易懂~ 这就是非对称加密的核心内容。这只是一个非常简单的示例，可能放在今天，随随便便的一台个人计算机就可以根据公钥20201破解出私钥19801。但是在没有计算机的年代，靠大量人工的算力也无法通过公钥破解出私钥。随着学者在数学领域的探索，非对称加密的实际应用早已结合了各种前沿的数学运算。当然了，这些都不是我等搬砖狗深究之事<del>~</del></p>
<h2 id="SSL原理"><a href="#SSL原理" class="headerlink" title="SSL原理"></a>SSL原理</h2><p>非对称加密虽然十分安全，但是性能比起对称加密则十分低下。而Bowser与Server之间的数据交互十分频繁，采用非对称加密显然不合适。</p>
<p>在SSL中，采用了非对称加密与对称加密相结合的方式。即<strong>Server通过非对称加密，把对称加密所使用的密钥，递交给Client</strong>。具体的过程，如下图所示：</p>
<p><img src=".//Blog15/SSL.jpg" alt></p>
<p>其中证书验证的环节，我们暂且不细究。此处涉及到的并非纯粹的技术问题，而是类似于互联网规章制度，感兴趣的同学可以自行了解一下。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="与Server的四种交互"><a href="#与Server的四种交互" class="headerlink" title="与Server的四种交互"></a>与Server的四种交互</h1><ol>
<li>GET    查询</li>
<li>POST   修改</li>
<li>PUT    增加</li>
<li>DELETE 删除</li>
</ol>
<p>实际上，单独的 GET / POST 就可以实现增删改查。</p>
<p>GET是幂等的（对同一个URL，多个请求返回相同结果）。</p>
<p>POST使用必须用到表单Form（所以很多人偷懒使用GET）。</p>
<p><strong>GET与POST的区别</strong>：</p>
<ol>
<li><p>GET提交的数据明文放在URL后边，不安全。<br>而POST则是把提交的数据放在HTTP包中加密传输，较为安全。</p>
</li>
<li><p>GET提交的数据量较小（最多1024字节）。<br>POST理论上无限制。</p>
</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="HTTP请求、响应"><a href="#HTTP请求、响应" class="headerlink" title="HTTP请求、响应"></a>HTTP请求、响应</h1><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>HTTP请求包含</p>
<ol>
<li>请求方法（GET/POST）</li>
<li>请求头<br>（空一行，表示请求头结束）</li>
<li>请求正文</li>
</ol>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>HTTP响应包含</p>
<ol>
<li>状态行（包含<strong>状态码</strong>）</li>
<li>响应头<br>（空一行，表示响应头结束）</li>
<li>响应正文</li>
</ol>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><h4 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h4><p><strong>信息码。</strong>Server已接收，Client可继续。</p>
<h4 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h4><p><strong>成功码。</strong>Server已接收并处理。</p>
<h4 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h4><p><strong>重定向码。</strong>服务器要求客户端重定向。</p>
<p>重定向：亦称URL转发，用于当前资源（页面）迁移到新URL。</p>
<h5 id="301"><a href="#301" class="headerlink" title="301"></a>301</h5><p><strong>永久重定向。</strong>例如<code>www.google.com</code>迁移到<code>google.com</code><br>优点：</p>
<ul>
<li>可以减少DNS的缓存（提高缓存友好型）</li>
<li>防止访问量分散（提高网站竞价排名）</li>
</ul>
<h5 id="302"><a href="#302" class="headerlink" title="302"></a>302</h5><p><strong>临时重定向。</strong>旧资源仍可访问，但临时跳转访问新资源。<br>优点：</p>
<ul>
<li>搜索引擎不会更新资源的链接，比301更利于SEO</li>
</ul>
<h4 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h4><p><strong>客户端错误码。</strong>Client的请求有非法内容。</p>
<h5 id="400"><a href="#400" class="headerlink" title="400"></a>400</h5><p>请求有语法错误。</p>
<h5 id="401"><a href="#401" class="headerlink" title="401"></a>401</h5><p>请求未经授权。</p>
<h5 id="403"><a href="#403" class="headerlink" title="403"></a>403</h5><p>Server收到，但拒绝提供服务（原因会写在响应正文中）。</p>
<h5 id="404"><a href="#404" class="headerlink" title="404"></a>404</h5><p>请求的资源不存在。</p>
<h4 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h4><p><strong>服务器错误码。</strong>Server未能正常处理请求。</p>
<h5 id="500"><a href="#500" class="headerlink" title="500"></a>500</h5><p>服务器Error。</p>
<h5 id="503"><a href="#503" class="headerlink" title="503"></a>503</h5><p>服务器当前无法处理（过段时间可能恢复）。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络协议</tag>
        <tag>HTTP</tag>
        <tag>对称加密</tag>
        <tag>非对称加密</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title>【笔记】 操作系统-进程与线程</title>
    <url>/Blog16.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><ol>
<li><p>匿名管道：<br>用于具有亲缘关系（父子、兄弟）的进程之间通信。</p>
</li>
<li><p>有名管道：<br>FIFO，任意两个进程。</p>
</li>
<li><p>信号：<br>用于<strong>通知某个进程</strong>发生了某事件。</p>
</li>
<li><p>消息队列：<br>FIFO，也可以随即查询，更灵活。<br>克服了信号信息承载量少的缺点。<br>克服了管道只支持字节流，缓冲区大小受限的缺点。</p>
</li>
<li><p>信号量：<br>是一个计数器，用于<strong>多进程访问共享数据</strong>，帮助进程间同步。</p>
</li>
<li><p>共享内存：<br>依赖于<strong>同步</strong>操作，<strong>最有用的</strong>进程间通信方式。</p>
</li>
<li><p>套接字：<br><strong>Client与Server的进程之间</strong>进行通信</p>
</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h1><ol>
<li><p>互斥量（MuteX）：<br>采用<strong>互斥对象机制</strong>(把对象加上互斥锁)，拥有互斥对象的线程才能访问。例如Java的Synchronized关键字及其各种锁。</p>
</li>
<li><p>信号量：<br>允许同一时刻，多个线程访问统一资源。但需控制最大线程数量。</p>
</li>
<li><p>事件（Event）：<br>wait() / notify()：通过通知操作，来保持多线程同步，还能实现优先级比较。</p>
</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h1><ol>
<li><p>先到先服务（FCFS）：<br>顾名思义，不解释。</p>
</li>
<li><p>短作业优先（SJF）：<br>顾名思义，不解释。</p>
</li>
<li><p>时间片轮转：<br>最古老、最公平、最简单、使用最广。</p>
</li>
<li><p>多级反馈队列：<br>高优先级 &amp;&amp; 短作业 的进程优先处理。公认效果较好，Unix用的就是这种调度算法。</p>
</li>
<li><p>优先级调度：<br>顾名思义，不解释。</p>
</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="OS内存管理"><a href="#OS内存管理" class="headerlink" title="OS内存管理"></a>OS内存管理</h1><h2 id="OS内存管理的内容"><a href="#OS内存管理的内容" class="headerlink" title="OS内存管理的内容"></a>OS内存管理的内容</h2><p>分配、回收、逻辑地址与物理地址的转换。</p>
<h2 id="OS内存管理的机制"><a href="#OS内存管理的机制" class="headerlink" title="OS内存管理的机制"></a>OS内存管理的机制</h2><ul>
<li><p>连续分配</p>
<ul>
<li>块式管理：<br>非常古老，把内存分为几个固定大小的块，每个块只存放一个进程。<br>&nbsp;</li>
</ul>
</li>
<li><p>非连续分配</p>
<ul>
<li><p>页式管理：<br>把内存划分为一页一页，页较小，比块式分配粒度更大，减少了碎片。通过页表中的映射，来管理逻辑与物理地址的转换。</p>
</li>
<li><p>段式管理：<br>粒度更小，进一步减少了碎片。每个段都定义了信息。</p>
</li>
<li><p>段页式管理：<br>内存先分成段，再分成页，并提高了运行时的安全性。<br>&nbsp;</p>
</li>
</ul>
</li>
</ul>
<p>分页与分段<br>相同处：提高内存利用率，减少了碎片。离散存储，但每个段/页都是连续的。<br>不同处：页的大小是固定的，段的大小取决于程序而变化。分页满足OS的性能需求，分段满足用户的动态需求。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="CPU寻址（虚拟寻址）"><a href="#CPU寻址（虚拟寻址）" class="headerlink" title="CPU寻址（虚拟寻址）"></a>CPU寻址（虚拟寻址）</h1><p>CPU将虚拟地址翻译为物理地址。这个过程需要CPU中的内存管理单元。</p>
<p>若无虚拟地址的存在（早期OS）的影响：程序可访问任意内存，不安全。且容易造成数据覆盖，很难同时运行多个程序。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>可以让程序拥有超出物理内存实际大小的空间，且为每个进程提供一致的、私有的空间。管理高效，减少出错。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h1><ul>
<li>时间局部性：执行了一条指令，通常不久后会再次执行。</li>
<li>空间局部性：访问了一个数据，通常不久后会再次访问。</li>
</ul>
]]></content>
      <tags>
        <tag>OS</tag>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-前序</title>
    <url>/Blog17.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p>设计模式（Design Patterns），用于解决“设计”上的问题（非算法、架构等）。其有四位作者，被称为“四人帮”（Gang Of Four），所以也用GOF代指设计模式。</p>
<p><strong>目的</strong>为了可重用代码，提高可扩展性和可维护性。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>六大原则</strong></p>
<ol>
<li><p>开闭原则：<br>对扩展开放，对修改关闭。</p>
</li>
<li><p>里氏代换原则：<br>面向对象的基本原则之一。任何父类可以出现的地方，子类也一定可以出现。</p>
</li>
<li><p>依赖倒转原则：<br>针对接口编程，依赖于抽象而不依赖于具体。</p>
</li>
<li><p>接口隔离原则：<br>使用多个接口好于使用单个接口（解耦）。</p>
</li>
<li><p>迪米特法则（最少知道原则）：<br>实体之间减少相互作用，各功能模块相对独立。</p>
</li>
<li><p>合成服用原则：<br>尽量使用组合，而非继承。</p>
</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>细分</strong></p>
<ul>
<li>创建型：提供创建对象 同时 隐藏创建逻辑 的方式。<ul>
<li>工厂与抽象工厂</li>
<li>单例</li>
<li>建造者</li>
<li>原型<br>&nbsp;</li>
</ul>
</li>
<li>结构型：关注类和对象的组合。<ul>
<li>适配器</li>
<li>装饰器</li>
<li>桥接</li>
<li>外观</li>
<li>代理</li>
<li>过滤器</li>
<li>组合</li>
<li>享元<br>&nbsp;</li>
</ul>
</li>
<li>行为型：关注对象之间的通信。<ul>
<li>责任链</li>
<li>观察者</li>
<li>模板</li>
<li>命令</li>
<li>解释器</li>
<li>迭代器</li>
<li>中介者</li>
<li>策略</li>
<li>状态</li>
<li>备忘录</li>
<li>空对象</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI网络模型</title>
    <url>/Blog18.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p>关于网络协议的分层，在网上流传着各种版本，其对应关系如下图所示：<br><img src=".//Blog18/compare.jpg" alt></p>
<p>接下来的部分，我会以最常用的五层协议来介绍。</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p><strong>数据单位</strong>：报文</p>
<p><strong>作用</strong>：直接为应用的进程提供服务（例如电子邮件，文件传输等）。</p>
<p><strong>常见协议</strong>：</p>
<ol>
<li>HTTP：超文本传输协议（HyperText Transfer Protocol）</li>
<li>DNS：域名系统（Domain Name System）</li>
<li>FTP：文件传输协议（File Transfer Protocol）</li>
<li>SMTP：简单邮件传输协议（Simple Mail Transfer Protocol）</li>
<li>Telnet：远程终端协议（远程控制服务器的方法）</li>
</ol>
<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p><strong>数据单位</strong>：报文段（Segment）</p>
<p><strong>作用</strong>：向两个主机之间的进程提供服务，由于一个主机有多个进程，所以运输层有<strong>分用</strong>和<strong>复用</strong>两种功能。</p>
<ul>
<li><p>分用：把运输层Segment中的信息分别发送给相应的Socket服务（运输层把收到的信息分别交付到应用层相关的进程）。</p>
</li>
<li><p>复用：把Socket中的数据集中，加头封装，发到网络层中（多个应用层进程同时使用运输层的服务）。</p>
</li>
</ul>
<p><strong>常见协议</strong>：</p>
<ol>
<li>TCP：传输控制协议（Transmission Control Protocol）</li>
<li>UDP：用户数据报协议（User Datagram Protocol）</li>
</ol>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p><strong>数据单位</strong>：IP数据报</p>
<p><strong>作用</strong>：选择合适的网间路由和交换节点。网络层把运输层产生的Segment装入IP数据报。</p>
<p><strong>常见协议</strong>：</p>
<ol>
<li>IP：网际互连协议（Internet Protocol）</li>
<li>ICMP：Internet控制报文协议（Internet Control Message Protocol）</li>
<li>ARP：地址解析协议（Address Resolution Protocol）</li>
</ol>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p><strong>数据单位</strong>：帧</p>
<p><strong>作用</strong>：把网络层交下来的IP数据报组装成帧，以及检测/纠错帧中的错误。即数据链路层提供了两个功能：帧编码 和 差错纠正控制。</p>
<p><strong>常见协议</strong>：Ethernet</p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p><strong>数据单位</strong>：比特（bit）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="常见协议及端口号"><a href="#常见协议及端口号" class="headerlink" title="常见协议及端口号"></a>常见协议及端口号</h1><ul>
<li>DHCP Server：67</li>
<li>DHCP Client：68<br>&nbsp;</li>
<li>POP3（邮件接收协议）：110</li>
<li>SMTP（邮件发送协议）：25<br>&nbsp;</li>
<li>Telnet：23<br>&nbsp;</li>
<li>FTP 数据传输：20</li>
<li>FTP 指令传输：21<br>&nbsp;</li>
<li>TFTP：69<br>&nbsp;</li>
<li>HTTP：80</li>
<li>HTTPS：443</li>
<li>DNS：53<br>&nbsp;</li>
<li>SSH：22<br>&nbsp;</li>
<li>MySQL：3306</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络协议</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title>【笔记】 Java异常机制</title>
    <url>/Blog19.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<h1 id="整体框架图"><a href="#整体框架图" class="headerlink" title="整体框架图"></a>整体框架图</h1><p><img src=".//Blog19/Frame.jpg" alt></p>
<h1 id="什么情况下finally不执行"><a href="#什么情况下finally不执行" class="headerlink" title="什么情况下finally不执行"></a>什么情况下finally不执行</h1><ul>
<li>finally第一行出错</li>
<li>其前面的代码用<code>System.exit()</code>推出程序</li>
<li>所在的线程死亡</li>
<li>CPU关闭</li>
</ul>
<h1 id="若try和finally中都有return"><a href="#若try和finally中都有return" class="headerlink" title="若try和finally中都有return"></a>若try和finally中都有return</h1><p>执行顺序：</p>
<ol>
<li>try中常规语句</li>
<li>finally中常规语句</li>
<li>finally中return</li>
<li>try中return</li>
</ol>
<h1 id="Throw-Throws"><a href="#Throw-Throws" class="headerlink" title="Throw/Throws"></a>Throw/Throws</h1><p>二者都是消极处理<br>Throw：抛出一个异常，出现在<strong>函数体</strong>。<br>Throws：<strong>声明</strong>方法可能抛出异常，出现在<strong>函数头</strong>。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>异常机制</tag>
      </tags>
  </entry>
  <entry>
    <title>【笔记】 ==与equals</title>
    <url>/Blog20.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p><img src=".//Blog20/01.jpg" alt></p>
<p>换一种理解方式：<br><img src=".//Blog20/02.jpg" alt></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【笔记】 接口与抽象类</title>
    <url>/Blog21.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="center">接口</th>
<th align="center">抽象类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">like-a</td>
<td align="center">is-a</td>
</tr>
<tr>
<td align="center">修饰符是public或default</td>
<td align="center">修饰符是public，protected，default</td>
</tr>
<tr>
<td align="center">变量修饰必须是static，final</td>
<td align="center">随便</td>
</tr>
<tr>
<td align="center">可以implements多个</td>
<td align="center">只能extends一个</td>
</tr>
<tr>
<td align="center">是对行为的抽象</td>
<td align="center">是对类的抽象</td>
</tr>
<tr>
<td align="center">是一种行为规范</td>
<td align="center">是一种设计模板</td>
</tr>
<tr>
<td align="center">不能有构造方法</td>
<td align="center">可以有构造方法</td>
</tr>
</tbody></table>
<p>ps：<strong>抽象类</strong>不能被实例化，只能被继承。实现了抽象类的抽象方法的子类 可实例化。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title>【笔记】 Override与Overload</title>
    <url>/Blog22.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<p><img src=".//Blog22/01.jpg" alt></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO流</title>
    <url>/Blog23.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<a id="more"></a>

<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul>
<li>基于字节：InputStream / OutputStream</li>
<li>基于字符：Reader / Writer</li>
<li>磁盘操作：File</li>
<li>网络操作：Socket</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="IO（BIO）"><a href="#IO（BIO）" class="headerlink" title="IO（BIO）"></a>IO（BIO）</h1><p>线程间是线性关系，效率低，易成为性能瓶颈。</p>
<p><strong>面向流</strong></p>
<p><strong>同步阻塞</strong></p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>Java1.4引入。</p>
<p>提供了新的三大特性：</p>
<ol>
<li>Buffer（数据）</li>
<li>Channel（运输）</li>
<li>Selector</li>
</ol>
<p><strong>面向缓冲区</strong></p>
<p><strong>同步非阻塞</strong></p>
<h1 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1><p>Java1.7引入。</p>
<p>提供了异步机制（基于回调）。</p>
<p><strong>异步非阻塞</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h1><p>指的是<strong>Client</strong>。<br>阻塞：Client发出请求，在得到回应前只能等待。<br>非阻塞：Client发出请求，在得到回应前可以做别的事（例如发送别的请求）。</p>
<h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>指的是<strong>Server</strong>。<br>同步：Server接收请求，在返回结果前不能接受其它请求。<br>异步：Server接收请求，在返回结果前可以接收其他请求。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
</search>
